/- Copyright 2022 ACL & MIdFF-/

import algebra.free_algebra
import algebra.ring_quot
import algebra.triv_sq_zero_ext
import algebra.algebra.operations
import linear_algebra.multilinear.basic

import ring_theory.graded_algebra.basic
import ring_theory.tensor_product
import data.mv_polynomial.supported

import data.rel



import ..weighted_homogeneous -- Modified version of PR #17855
import ..graded_ring_quot -- Quotients of graded rings
import ..graded_module_quot

noncomputable theory

/-! 
The divided power algebra of a module -/

open finset mv_polynomial ring_quot direct_sum ideal ideal.quotient

theorem ideal.pow_eq_bot {R : Type*} [comm_semiring R] [no_zero_divisors R] {I : ideal R} 
  {n : â„•} (hn : n â‰  0) :
  I ^ n = âŠ¥ â†” I = âŠ¥ :=
begin
  induction n with n ih,
  { exfalso, exact hn (eq.refl _) },
  { by_cases hn0 : n = 0,
    { rw [hn0, pow_one] },
    { rw [pow_succ, mul_eq_bot, ih hn0, or_self] }}
end

namespace mv_polynomial

variables {R S Ïƒ : Type*} [comm_semiring R] [comm_semiring S] 

@[simp] lemma evalâ‚‚_hom.smul (f : R â†’+* S) (g : Ïƒ â†’ S) (r : R) (P : mv_polynomial Ïƒ R) :
  evalâ‚‚_hom f g (r â€¢ P) = f r â€¢ evalâ‚‚_hom f g P := 
by simp only [smul_eq_C_mul, coe_evalâ‚‚_hom, evalâ‚‚_mul, evalâ‚‚_C, algebra.id.smul_eq_mul]

variables [algebra R S]

variable (R)
/-- `mv_polynomial.evalâ‚‚ (algebra_map R S) g` as an `R`-algebra homomorphism. -/
def evalâ‚‚_alg_hom  (g : Ïƒ â†’ S) :
  mv_polynomial Ïƒ R â†’â‚[R] S := 
{ commutes' := Î» r, by rw [ring_hom.to_fun_eq_coe, coe_evalâ‚‚_hom, algebra_map_eq, evalâ‚‚_C], 
  .. evalâ‚‚_hom (algebra_map R S) g }

variable {R}
lemma evalâ‚‚_alg_hom_apply (g : Ïƒ â†’ S) (P : mv_polynomial Ïƒ R) :
  evalâ‚‚_alg_hom R g P = evalâ‚‚_hom (algebra_map R S) g P := rfl

@[simp] lemma coe_evalâ‚‚_alg_hom (g : Ïƒ â†’ S) :
  â‡‘(evalâ‚‚_alg_hom R g) = evalâ‚‚ (algebra_map R S) g := rfl

@[simp] lemma evalâ‚‚_alg_hom_X' (g : Ïƒ â†’ S) (i : Ïƒ) :
  evalâ‚‚_alg_hom R g ((X i : mv_polynomial Ïƒ R)) = g i := 
evalâ‚‚_X (algebra_map R S)  g i

end mv_polynomial

section ideals_and_rel

lemma quotient_mk_eq_of_rel {A : Type*} [comm_ring A] {r : A â†’ A â†’ Prop} {a b : A} (h : r a b) :
  mk (of_rel r) a = mk (of_rel r) b :=
begin
  suffices hinj : function.injective (ring_quot.ring_quot_equiv_ideal_quotient r).inv_fun,
  { apply hinj, exact mk_ring_hom_rel h },
  exact function.injective_iff_has_left_inverse.mpr âŸ¨(ring_quot_equiv_ideal_quotient r).to_fun,
    (ring_quot_equiv_ideal_quotient r).right_invâŸ©,
end

namespace ideal

lemma quotient_mk_eq_ring_quot_apply (R : Type*) [comm_ring R] {A : Type*} [comm_ring A]
  [algebra R A] (r : A â†’ A â†’ Prop) (a : A) :
  mk (of_rel r) a = ring_quot_to_ideal_quotient r (mk_alg_hom R r a) :=
by rw [â† ring_quot_to_ideal_quotient_apply r a, â† mk_alg_hom_coe R r];  refl

namespace quotient 

variables {R S : Type*} [comm_ring R] [comm_ring S]

lemma rel_le_ker (I : ideal R) {r : R â†’ R â†’ Prop} (hr : I = of_rel r) (f : R â†’+* S) 
  (hf : âˆ€ {a b : R}, r a b â†’ f a = f b) : I â‰¤ f.ker :=
begin
  rw [hr, of_rel, submodule.span_le],
  rintros x âŸ¨a, b, hx, habâŸ©,
  rw [eq_sub_iff_add_eq.mpr hab, set_like.mem_coe, ring_hom.mem_ker, map_sub, sub_eq_zero, hf hx]
end

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R â†’+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def lift_rel  (I : ideal R) {r : R â†’ R â†’ Prop} (hr : I = of_rel r) (f : R â†’+* S)
  (hf : âˆ€ (a b : R), r a b â†’ f a = f b) : R â§¸ I â†’+* S :=
lift I f (rel_le_ker I hr f hf)

end quotient

end ideal

end ideals_and_rel

namespace triv_sq_zero_ext

variables (R M : Type*) [comm_semiring R] [add_comm_monoid M] [module R M] [module Ráµáµ’áµ– M]
  [is_central_scalar R M]

def ker_ideal : ideal (triv_sq_zero_ext R M) := ring_hom.ker (fst_hom R R M)

lemma mem_ker_ideal_iff_inr (x : triv_sq_zero_ext R M) :
  (x âˆˆ ker_ideal R M â†” x = inr x.snd) :=
begin
  obtain âŸ¨r, mâŸ© := x,
  simp only [ker_ideal, ring_hom.mem_ker, fst_hom_apply, fst_mk],
  exact âŸ¨Î» hr, by {rw hr, refl}, Î» hrm, by rw [â† fst_mk r m, hrm, fst_inr]âŸ©,
end

lemma mem_ker_ideal_iff_exists (x : triv_sq_zero_ext R M) :
  (x âˆˆ ker_ideal R M â†” âˆƒ (m : M), x = inr m) :=
by rw mem_ker_ideal_iff_inr; exact âŸ¨Î» h, âŸ¨x.snd, hâŸ©, Î» âŸ¨m, hmâŸ©, by {rw hm, refl}âŸ©


lemma square_zero : (ker_ideal R M) ^ 2 = 0 := 
begin
  simp only [pow_two, zero_eq_bot, eq_bot_iff, mul_le, mem_ker_ideal_iff_inr],
  rintros x hx y hy, 
  rw [hx, hy, mem_bot, inr_mul_inr],
end

end triv_sq_zero_ext

open ideal ideal.quotient triv_sq_zero_ext

section graded_algebra

variables {R : Type*} [comm_ring R]
variables {A : Type*} [comm_ring A] [algebra R A]
variables {Î¹ : Type*} [canonically_ordered_add_monoid Î¹]
variables (ğ’œ : Î¹ â†’ submodule R A)

lemma grade_zero_coe_smul (r : R) (x : ğ’œ 0) : (â†‘(r â€¢ x) : A) = r â€¢ x := rfl 

variables  [decidable_eq Î¹] [graded_algebra ğ’œ]
instance : has_one â†¥(ğ’œ 0) := 
âŸ¨âŸ¨1, (@graded_ring.to_graded_monoid Î¹ A (submodule R A) _ _ _ _ _ ğ’œ _).one_memâŸ©âŸ©

instance : has_mul â†¥(ğ’œ 0) := 
âŸ¨Î» x y, âŸ¨x * y, by convert set_like.mul_mem_graded x.2 y.2; rw [add_zero]âŸ©âŸ©

@[simp] lemma grade_zero_coe_mul (x y : ğ’œ 0) : (â†‘(x * y) : A) = x * y := rfl 

@[simp] lemma grade_zero_val_mul (x y : ğ’œ 0) : (x * y).val = x.val * y.val := rfl

@[simp] lemma grade_zero_coe_one : (â†‘(1 : ğ’œ 0) : A) = 1 := rfl

lemma one_mem : (1 : A) âˆˆ ğ’œ 0 := set_like.one_mem_graded ğ’œ

example : add_comm_monoid (ğ’œ 0) := infer_instance

example : has_neg (ğ’œ 0) := add_subgroup_class.has_neg

instance grade_zero_comm_ring : comm_ring â†¥(ğ’œ 0) := { 
  add           := (+),
  zero          := 0,
  neg           := has_neg.neg,
  one           := 1,
  mul           := (*),
  mul_assoc     := Î» x y z, by ext; simp only [grade_zero_coe_mul, mul_assoc],
  one_mul       := Î» x, by  ext; rw [grade_zero_coe_mul, grade_zero_coe_one, one_mul],
  mul_one       := Î» x, by  ext; rw [grade_zero_coe_mul, grade_zero_coe_one, mul_one],
  left_distrib  := Î» x y z, by ext; simp only [submodule.coe_add, grade_zero_coe_mul, left_distrib],
  right_distrib := Î» x y z, 
    by ext; simp only [submodule.coe_add, grade_zero_coe_mul, right_distrib],
  mul_comm      := Î» x y, by ext; simp only [grade_zero_coe_mul, mul_comm],
  ..(infer_instance : add_comm_group (ğ’œ 0)) }

instance grade_zero_algebra : algebra R â†¥(ğ’œ 0) := algebra.of_module'
  (Î» r x, by ext; simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one, 
    algebra.smul_mul_assoc, one_mul])
  (Î» r x, by ext; simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one, 
    algebra.mul_smul_comm, mul_one])

/-- The projection from `A` to the degree `i` component `ğ’œ i`, as an `R`-linear map. -/
def proj (i : Î¹) : A â†’â‚—[R] (ğ’œ i) :=
{ to_fun    := Î» a, decompose ğ’œ a i,
  map_add'  := Î» a b, by rw [decompose_add, add_apply],
  map_smul' := Î» r a, by rw [decompose_smul, dfinsupp.coe_smul, pi.smul_apply, ring_hom.id_apply] }

@[simps] def proj_zero_ring_hom' : A â†’+* (ğ’œ 0) :=
{ to_fun := Î» a, proj ğ’œ 0 a,
  map_one' := begin 
    ext,
    simp only [proj, linear_map.coe_mk, decompose_of_mem_same ğ’œ (one_mem ğ’œ),
    grade_zero_coe_one], 
  end,
  map_zero' := by { simp only [proj, decompose_zero, linear_map.coe_mk, zero_apply] },
  map_add' := Î» _ _, by { simp only [proj, decompose_add, linear_map.coe_mk, add_apply] },
  map_mul' := Î» x y, begin
    ext,
    simp only [proj, linear_map.coe_mk, set_like.coe_eq_coe, grade_zero_coe_mul, 
      â† graded_ring.proj_zero_ring_hom_apply ğ’œ, â† _root_.map_mul],
  end }


end graded_algebra

section graded_algebra

variables {R : Type*} [comm_ring R]

def galg_hom.is_homogeneous {Î¹ : Type*} {A : Type*} [comm_ring A] [algebra R A] 
  (ğ’œ : Î¹ â†’ submodule R A) {B : Type*} [comm_ring B] [algebra R B] (â„¬ : Î¹ â†’ submodule R B)
  (f : A â†’â‚[R] B) := 
âˆ€ i a, a âˆˆ ğ’œ i â†’ f a âˆˆ â„¬ i

lemma finsupp.prod.mem_grade {Îº A : Type*} [add_comm_monoid Îº] [decidable_eq Îº] [comm_ring A] 
  [algebra R A] (ğ’œ : Îº â†’ submodule R A) [graded_algebra ğ’œ] {Ïƒ : Type*} (c : Ïƒ â†’â‚€ â„•) (f : Ïƒ â†’ A) 
  (d : Ïƒ â†’ Îº ) (hc : âˆ€ s âˆˆ c.support, f s âˆˆ ğ’œ (d s)) : 
  c.prod (Î» s e, (f s) ^ e) âˆˆ ğ’œ (c.sum (Î» s e, e â€¢ d s)) := 
begin
  classical,
  rw [finsupp.prod, finsupp.sum],
  let p : finset Ïƒ â†’ Prop := 
  Î» s, s âŠ† c.support â†’ (s.prod (Î» i, (f i) ^ c i) âˆˆ ğ’œ (s.sum (Î» i, c i â€¢ d i))),
  apply @finset.induction_on Ïƒ p _ c.support,
  { exact imp_intro (set_like.one_mem_graded ğ’œ) },
  { intros a s ha hs,
    by_cases hs' : (insert a s) âŠ† c.support,  
    { apply imp_intro,
      rw [finset.prod_insert ha, finset.sum_insert ha],
      exact set_like.mul_mem_graded (set_like.pow_mem_graded _ (hc a (hs' (mem_insert_self a s))))
       (hs (subset_trans (subset_insert a s) hs')) },
    { exact not.elim hs' }},
  { exact subset_rfl },
end

def galg_hom.is_homogeneous' {Î¹ Îº : Type*} /- [add_comm_monoid Î¹] [decidable_eq Î¹] -/
  (A : Type*) [comm_ring A] [algebra R A] (ğ’œ : Î¹ â†’ submodule R A) /- [graded_algebra ğ’œ] -/
  (B : Type*) [comm_ring B] [algebra R B] (â„¬ : Îº â†’ submodule R B) /- [graded_algebra â„¬]  -/
  (Ï† : Î¹ â†’ Îº) (f : A â†’â‚[R] B) := 
âˆ€ i a, a âˆˆ ğ’œ i â†’ f a âˆˆ â„¬ (Ï† i)

lemma foo (Ïƒ : Type*) {Î¹ Îº : Type*} [add_comm_monoid Î¹] --[decidable_eq Î¹]
  [add_comm_monoid Îº] [decidable_eq Îº]
  (A : Type*) [comm_ring A] [algebra R A] (ğ’œ : Îº â†’ submodule R A) 
  [graded_algebra ğ’œ] (w : Ïƒ â†’ Î¹) (Ï† : Î¹ â†’+ Îº) (f : Ïƒ â†’ A) 
  (h : âˆ€ s : Ïƒ, f s âˆˆ ğ’œ (Ï† (w s))) : 
  galg_hom.is_homogeneous' _ (weighted_homogeneous_submodule R w ) _ ğ’œ Ï†
    (mv_polynomial.aeval f) :=
begin
  intros i p hp,
  simp only [mem_weighted_homogeneous_submodule, is_weighted_homogeneous] at hp,
  rw p.as_sum,
  rw map_sum,
  apply submodule.sum_mem,
  intros c hc,
  rw aeval_monomial,
  rw â† smul_eq_mul, 
  rw algebra_map_smul,
  apply submodule.smul_mem, 
  convert finsupp.prod.mem_grade ğ’œ c f _ (Î» s _, h s ),
  rw â† hp (mem_support_iff.mp hc),
  simp only [weighted_degree'],
  rw finsupp.total,
  simp only [finsupp.coe_lsum, finsupp.sum],
  rw map_sum,
  simp only [linear_map.coe_smul_right, linear_map.id_coe, id.def, algebra.id.smul_eq_mul],
  apply congr_arg2 _ rfl,
  ext s,
  rw add_monoid_hom.map_nsmul,
end

end graded_algebra

lemma mv_polynomial.vars_X_subset {R : Type*} {Ïƒ : Type*} (n : Ïƒ) [comm_semiring R] :
  (X n : mv_polynomial Ïƒ R).vars âŠ† {n} := 
begin
  classical,
  intro u,
  rw [X, mem_vars, mem_singleton], 
  rintro âŸ¨c, hc, hc'âŸ©,
  by_contradiction h', 
  rw [mem_support_iff, coeff_monomial, ne.def] at hc, 
  by_cases h : finsupp.single n 1 = c,
  { rw [â† h, finsupp.mem_support_iff, ne.def, finsupp.single_apply] at hc',
    apply hc', rw if_neg (ne.symm h'), },
  { apply hc, rw if_neg h, },
end

section

open mv_polynomial 

variables {R M : Type*} [comm_ring R]

instance :
  graded_algebra (weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•)) := 
weighted_graded_algebra _ _

variable {R}
def degree (v : (â„• Ã— M) â†’â‚€ â„•) : â„• := finsum (Î» x, (v x) * x.1)

def is_homogeneous_of_degree (p : mv_polynomial (â„• Ã— M) R) (n : â„•) : Prop :=
âˆ€ v âˆˆ p.support, degree v = n

variable (R)

lemma variable_mem_supported (nm : â„• Ã— M) (hn : 0 < nm.1) :
  X nm âˆˆ supported R {nm : â„• Ã— M | 0 < nm.1} :=
begin
  rw mem_supported,
  refine set.subset.trans (finset.coe_subset.mpr (vars_X_subset nm)) _,
  rw [coe_singleton, set.singleton_subset_iff, set.mem_set_of_eq],
  exact hn,
end

def to_supported : mv_polynomial (â„• Ã— M) R â†’â‚[R] supported R {nm : â„• Ã— M | 0 < nm.1} :=  
aeval (Î» (nm : â„• Ã— M), dite (0 < nm.1) (Î» h, âŸ¨(X nm), (variable_mem_supported R nm h)âŸ©) (Î» h, 1))

lemma to_supported_is_homogeneous : 
  galg_hom.is_homogeneous' (mv_polynomial (â„• Ã— M) R)
    (weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•)) (mv_polynomial (â„• Ã— M) R)
    (weighted_homogeneous_submodule R prod.fst) (id : â„• â†’ â„•)
    ((subalgebra.val _).comp (to_supported R)) :=
begin
  classical,
  have h := @foo R _ (â„• Ã— M) â„• â„• _ _ _ (mv_polynomial (â„• Ã— M) R) _ _
  (weighted_homogeneous_submodule R prod.fst) _ prod.fst (add_monoid_hom.id â„•)
  ((subalgebra.val _).to_fun.comp (Î» (nm : â„• Ã— M), 
    dite (0 < nm.1) (Î» h, âŸ¨(X nm), (variable_mem_supported R nm h)âŸ©) (Î» h, 1))) _,
  have heq : (aeval ((supported R {nm : â„• Ã— M | 0 < nm.fst}).val.to_fun âˆ˜ 
    Î» (nm : â„• Ã— M), dite (0 < nm.fst) (Î» (h : 0 < nm.fst), âŸ¨X nm, _âŸ©) (Î» (h : Â¬0 < nm.fst), 1))) =
    ((supported R {nm : â„• Ã— M | 0 < nm.fst}).val.comp (to_supported R)),
  { apply mv_polynomial.alg_hom_ext,
    intros nm,
    simp only [to_supported, alg_hom.to_fun_eq_coe, function.comp_app, alg_hom.coe_comp, aeval_X] },
  rw heq at h,
  exact h,
  { intros nm,
    simp only [mem_weighted_homogeneous_submodule, alg_hom.to_fun_eq_coe, subalgebra.coe_val, 
      function.comp_app, add_monoid_hom.id_apply],
    split_ifs,
    { exact is_weighted_homogeneous_X R _ _, },
    { simp only [not_lt, le_zero_iff] at h,
      rw [h, algebra_map.coe_one],
      exact is_weighted_homogeneous_one R _, }}
end

variable (M)
-- TODO: generalize
lemma eq_finsupp_single_of_degree_one {d : â„• Ã— M â†’â‚€ â„•} (hd : (weighted_degree' prod.fst) d = 1)
  (hsupp : âˆ€ (nm : â„• Ã— M), nm âˆˆ d.support â†’ 0 < nm.fst) :
  âˆƒ (m : M), finsupp.single (1, m) 1 = d :=
begin
  classical,
  rw [weighted_degree', finsupp.total_apply, finsupp.sum] at hd,
  have hnm : âˆƒ (nm : â„• Ã— M), d nm â€¢ nm.fst = 1,
  { by_contra h0,
    rw [not_exists] at h0,
    have hd0 : d.support.sum (Î» (a : â„• Ã— M), d a â€¢ a.fst) = 0,
    { rw finset.sum_eq_zero,
      intros nm hnm,
      rw â† nat.lt_one_iff,
      apply lt_of_le_of_ne _ (h0 nm),
      rw â† hd,
      exact finset.single_le_sum (Î»ab hab,  zero_le _ ) hnm },
    rw [hd0] at hd,
    exact zero_ne_one hd, },
  obtain âŸ¨nm, hnmâŸ© := hnm,
  rw â† hnm at hd,
  rw [algebra.id.smul_eq_mul, nat.mul_eq_one_iff] at hnm,
  use nm.snd,
  ext ab,
  rw finsupp.single_apply,
  split_ifs with hab;
  rw [â† hnm.2, eq_comm, prod.mk.eta] at hab,
  { rw [hab, hnm.1], },
  { rw eq_comm,
    by_contra hab',
    have hne0 : d ab * ab.fst â‰  0,
    { exact mul_ne_zero hab' (ne_of_gt (hsupp ab (finsupp.mem_support_iff.mpr hab'))) },
    have hnm_mem : nm âˆˆ d.support,
    { rw [finsupp.mem_support_iff, hnm.1], exact one_ne_zero },
    simp only [finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self, 
      algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff, finsupp.mem_support_iff, --ne.def, 
      mem_singleton] at hd,
    exact hne0 (hd ab âŸ¨hab', habâŸ©) },
end

#where

end 