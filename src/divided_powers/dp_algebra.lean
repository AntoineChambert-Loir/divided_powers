/- Copyright 2022 ACL & MIdFF-/

import algebra.free_algebra
import algebra.ring_quot
import algebra.triv_sq_zero_ext
import algebra.algebra.operations
import linear_algebra.multilinear.basic

import ring_theory.graded_algebra.basic
import ring_theory.tensor_product
import data.mv_polynomial.supported

import data.rel

import divided_powers.basic
import divided_powers.sub_pd_ideal
import divided_powers.rat_algebra
import divided_powers.ideal_add
import ..weighted_homogeneous -- Modified version of PR #17855
import ..graded_ring_quot -- Quotients of graded rings
import ..graded_module_quot

noncomputable theory

/-! 
The divided power algebra of a module -/

open finset mv_polynomial ring_quot direct_sum ideal ideal.quotient

theorem ideal.pow_eq_bot {R : Type*} [comm_semiring R] [no_zero_divisors R] {I : ideal R} 
  {n : â„•} (hn : n â‰  0) :
  I ^ n = âŠ¥ â†” I = âŠ¥ :=
begin
  induction n with n ih,
  { exfalso, exact hn (eq.refl _) },
  { by_cases hn0 : n = 0,
    { rw [hn0, pow_one] },
    { rw [pow_succ, mul_eq_bot, ih hn0, or_self] }}
end

namespace mv_polynomial

variables {R S Ïƒ : Type*} [comm_semiring R] [comm_semiring S] 

@[simp] lemma evalâ‚‚_hom.smul (f : R â†’+* S) (g : Ïƒ â†’ S) (r : R) (P : mv_polynomial Ïƒ R) :
  evalâ‚‚_hom f g (r â€¢ P) = f r â€¢ evalâ‚‚_hom f g P := 
by simp only [smul_eq_C_mul, coe_evalâ‚‚_hom, evalâ‚‚_mul, evalâ‚‚_C, algebra.id.smul_eq_mul]

variables [algebra R S]

variable (R)
/-- `mv_polynomial.evalâ‚‚ (algebra_map R S) g` as an `R`-algebra homomorphism. -/
def evalâ‚‚_alg_hom  (g : Ïƒ â†’ S) :
  mv_polynomial Ïƒ R â†’â‚[R] S := 
{ commutes' := Î» r, by rw [ring_hom.to_fun_eq_coe, coe_evalâ‚‚_hom, algebra_map_eq, evalâ‚‚_C], 
  .. evalâ‚‚_hom (algebra_map R S) g }

variable {R}
lemma evalâ‚‚_alg_hom_apply (g : Ïƒ â†’ S) (P : mv_polynomial Ïƒ R) :
  evalâ‚‚_alg_hom R g P = evalâ‚‚_hom (algebra_map R S) g P := rfl

@[simp] lemma coe_evalâ‚‚_alg_hom (g : Ïƒ â†’ S) :
  â‡‘(evalâ‚‚_alg_hom R g) = evalâ‚‚ (algebra_map R S) g := rfl

@[simp] lemma evalâ‚‚_alg_hom_X' (g : Ïƒ â†’ S) (i : Ïƒ) :
  evalâ‚‚_alg_hom R g ((X i : mv_polynomial Ïƒ R)) = g i := 
evalâ‚‚_X (algebra_map R S)  g i

end mv_polynomial

section ideals_and_rel

lemma quotient_mk_eq_of_rel {A : Type*} [comm_ring A] {r : A â†’ A â†’ Prop} {a b : A} (h : r a b) :
  mk (of_rel r) a = mk (of_rel r) b :=
begin
  suffices hinj : function.injective (ring_quot.ring_quot_equiv_ideal_quotient r).inv_fun,
  { apply hinj, exact mk_ring_hom_rel h },
  exact function.injective_iff_has_left_inverse.mpr âŸ¨(ring_quot_equiv_ideal_quotient r).to_fun,
    (ring_quot_equiv_ideal_quotient r).right_invâŸ©,
end

namespace ideal

lemma quotient_mk_eq_ring_quot_apply (R : Type*) [comm_ring R] {A : Type*} [comm_ring A]
  [algebra R A] (r : A â†’ A â†’ Prop) (a : A) :
  mk (of_rel r) a = ring_quot_to_ideal_quotient r (mk_alg_hom R r a) :=
by rw [â† ring_quot_to_ideal_quotient_apply r a, â† mk_alg_hom_coe R r];  refl

namespace quotient 

variables {R S : Type*} [comm_ring R] [comm_ring S]

lemma rel_le_ker (I : ideal R) {r : R â†’ R â†’ Prop} (hr : I = of_rel r) (f : R â†’+* S) 
  (hf : âˆ€ {a b : R}, r a b â†’ f a = f b) : I â‰¤ f.ker :=
begin
  rw [hr, of_rel, submodule.span_le],
  rintros x âŸ¨a, b, hx, habâŸ©,
  rw [eq_sub_iff_add_eq.mpr hab, set_like.mem_coe, ring_hom.mem_ker, map_sub, sub_eq_zero, hf hx]
end

/-- Given a binary relation `r` on `R` and a ring homomorphism `f : R â†’+* S` that is constant on
  each equivalent class of `r`, lift `f` to the quotient by the ideal generated by `r`. -/
def lift_rel  (I : ideal R) {r : R â†’ R â†’ Prop} (hr : I = of_rel r) (f : R â†’+* S)
  (hf : âˆ€ (a b : R), r a b â†’ f a = f b) : R â§¸ I â†’+* S :=
lift I f (rel_le_ker I hr f hf)

end quotient

end ideal

end ideals_and_rel

namespace triv_sq_zero_ext

variables (R M : Type*) [comm_semiring R] [add_comm_monoid M] [module R M] [module Ráµáµ’áµ– M]
  [is_central_scalar R M]

def ker_ideal : ideal (triv_sq_zero_ext R M) := ring_hom.ker (fst_hom R R M)

lemma mem_ker_ideal_iff_inr (x : triv_sq_zero_ext R M) :
  (x âˆˆ ker_ideal R M â†” x = inr x.snd) :=
begin
  obtain âŸ¨r, mâŸ© := x,
  simp only [ker_ideal, ring_hom.mem_ker, fst_hom_apply, fst_mk],
  exact âŸ¨Î» hr, by {rw hr, refl}, Î» hrm, by rw [â† fst_mk r m, hrm, fst_inr]âŸ©,
end

lemma mem_ker_ideal_iff_exists (x : triv_sq_zero_ext R M) :
  (x âˆˆ ker_ideal R M â†” âˆƒ (m : M), x = inr m) :=
by rw mem_ker_ideal_iff_inr; exact âŸ¨Î» h, âŸ¨x.snd, hâŸ©, Î» âŸ¨m, hmâŸ©, by {rw hm, refl}âŸ©


lemma square_zero : (ker_ideal R M) ^ 2 = 0 := 
begin
  simp only [pow_two, zero_eq_bot, eq_bot_iff, mul_le, mem_ker_ideal_iff_inr],
  rintros x hx y hy, 
  rw [hx, hy, mem_bot, inr_mul_inr],
end

end triv_sq_zero_ext

open ideal ideal.quotient triv_sq_zero_ext

section graded_algebra

variables {R : Type*} [comm_ring R]
variables {A : Type*} [comm_ring A] [algebra R A]
variables {Î¹ : Type*} [canonically_ordered_add_monoid Î¹]
variables (ğ’œ : Î¹ â†’ submodule R A)

lemma grade_zero_coe_smul (r : R) (x : ğ’œ 0) : (â†‘(r â€¢ x) : A) = r â€¢ x := rfl 

variables  [decidable_eq Î¹] [graded_algebra ğ’œ]
instance : has_one â†¥(ğ’œ 0) := 
âŸ¨âŸ¨1, (@graded_ring.to_graded_monoid Î¹ A (submodule R A) _ _ _ _ _ ğ’œ _).one_memâŸ©âŸ©

instance : has_mul â†¥(ğ’œ 0) := 
âŸ¨Î» x y, âŸ¨x * y, by convert set_like.mul_mem_graded x.2 y.2; rw [add_zero]âŸ©âŸ©

@[simp] lemma grade_zero_coe_mul (x y : ğ’œ 0) : (â†‘(x * y) : A) = x * y := rfl 

@[simp] lemma grade_zero_val_mul (x y : ğ’œ 0) : (x * y).val = x.val * y.val := rfl

@[simp] lemma grade_zero_coe_one : (â†‘(1 : ğ’œ 0) : A) = 1 := rfl

lemma one_mem : (1 : A) âˆˆ ğ’œ 0 := set_like.one_mem_graded ğ’œ

example : add_comm_monoid (ğ’œ 0) := infer_instance

example : has_neg (ğ’œ 0) := add_subgroup_class.has_neg

instance grade_zero_comm_ring : comm_ring â†¥(ğ’œ 0) := { 
  add           := (+),
  zero          := 0,
  neg           := has_neg.neg,
  one           := 1,
  mul           := (*),
  mul_assoc     := Î» x y z, by ext; simp only [grade_zero_coe_mul, mul_assoc],
  one_mul       := Î» x, by  ext; rw [grade_zero_coe_mul, grade_zero_coe_one, one_mul],
  mul_one       := Î» x, by  ext; rw [grade_zero_coe_mul, grade_zero_coe_one, mul_one],
  left_distrib  := Î» x y z, by ext; simp only [submodule.coe_add, grade_zero_coe_mul, left_distrib],
  right_distrib := Î» x y z, 
    by ext; simp only [submodule.coe_add, grade_zero_coe_mul, right_distrib],
  mul_comm      := Î» x y, by ext; simp only [grade_zero_coe_mul, mul_comm],
  ..(infer_instance : add_comm_group (ğ’œ 0)) }

instance grade_zero_algebra : algebra R â†¥(ğ’œ 0) := algebra.of_module'
  (Î» r x, by ext; simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one, 
    algebra.smul_mul_assoc, one_mul])
  (Î» r x, by ext; simp only [grade_zero_coe_mul, grade_zero_coe_smul, grade_zero_coe_one, 
    algebra.mul_smul_comm, mul_one])

/-- The projection from `A` to the degree `i` component `ğ’œ i`, as an `R`-linear map. -/
def proj (i : Î¹) : A â†’â‚—[R] (ğ’œ i) :=
{ to_fun    := Î» a, decompose ğ’œ a i,
  map_add'  := Î» a b, by rw [decompose_add, add_apply],
  map_smul' := Î» r a, by rw [decompose_smul, dfinsupp.coe_smul, pi.smul_apply, ring_hom.id_apply] }

@[simps] def proj_zero_ring_hom' : A â†’+* (ğ’œ 0) :=
{ to_fun := Î» a, proj ğ’œ 0 a,
  map_one' := begin 
    ext,
    simp only [proj, linear_map.coe_mk, decompose_of_mem_same ğ’œ (one_mem ğ’œ),
    grade_zero_coe_one], 
  end,
  map_zero' := by { simp only [proj, decompose_zero, linear_map.coe_mk, zero_apply] },
  map_add' := Î» _ _, by { simp only [proj, decompose_add, linear_map.coe_mk, add_apply] },
  map_mul' := Î» x y, begin
    ext,
    simp only [proj, linear_map.coe_mk, set_like.coe_eq_coe, grade_zero_coe_mul, 
      â† graded_ring.proj_zero_ring_hom_apply ğ’œ, â† _root_.map_mul],
  end }


end graded_algebra

section graded_algebra

variables {R : Type*} [comm_ring R]

def galg_hom.is_homogeneous {Î¹ : Type*} {A : Type*} [comm_ring A] [algebra R A] 
  (ğ’œ : Î¹ â†’ submodule R A) {B : Type*} [comm_ring B] [algebra R B] (â„¬ : Î¹ â†’ submodule R B)
  (f : A â†’â‚[R] B) := 
âˆ€ i a, a âˆˆ ğ’œ i â†’ f a âˆˆ â„¬ i

lemma finsupp.prod.mem_grade {Îº A : Type*} [add_comm_monoid Îº] [decidable_eq Îº] [comm_ring A] 
  [algebra R A] (ğ’œ : Îº â†’ submodule R A) [graded_algebra ğ’œ] {Ïƒ : Type*} (c : Ïƒ â†’â‚€ â„•) (f : Ïƒ â†’ A) 
  (d : Ïƒ â†’ Îº ) (hc : âˆ€ s âˆˆ c.support, f s âˆˆ ğ’œ (d s)) : 
  c.prod (Î» s e, (f s) ^ e) âˆˆ ğ’œ (c.sum (Î» s e, e â€¢ d s)) := 
begin
  classical,
  rw [finsupp.prod, finsupp.sum],
  let p : finset Ïƒ â†’ Prop := 
  Î» s, s âŠ† c.support â†’ (s.prod (Î» i, (f i) ^ c i) âˆˆ ğ’œ (s.sum (Î» i, c i â€¢ d i))),
  apply @finset.induction_on Ïƒ p _ c.support,
  { exact imp_intro (set_like.one_mem_graded ğ’œ) },
  { intros a s ha hs,
    by_cases hs' : (insert a s) âŠ† c.support,  
    { apply imp_intro,
      rw [finset.prod_insert ha, finset.sum_insert ha],
      exact set_like.mul_mem_graded (set_like.pow_mem_graded _ (hc a (hs' (mem_insert_self a s))))
       (hs (subset_trans (subset_insert a s) hs')) },
    { exact not.elim hs' }},
  { exact subset_rfl },
end

def galg_hom.is_homogeneous' {Î¹ Îº : Type*} /- [add_comm_monoid Î¹] [decidable_eq Î¹] -/
  (A : Type*) [comm_ring A] [algebra R A] (ğ’œ : Î¹ â†’ submodule R A) /- [graded_algebra ğ’œ] -/
  (B : Type*) [comm_ring B] [algebra R B] (â„¬ : Îº â†’ submodule R B) /- [graded_algebra â„¬]  -/
  (Ï† : Î¹ â†’ Îº) (f : A â†’â‚[R] B) := 
âˆ€ i a, a âˆˆ ğ’œ i â†’ f a âˆˆ â„¬ (Ï† i)

lemma foo (Ïƒ : Type*) {Î¹ Îº : Type*} [add_comm_monoid Î¹] --[decidable_eq Î¹]
  [add_comm_monoid Îº] [decidable_eq Îº]
  (A : Type*) [comm_ring A] [algebra R A] (ğ’œ : Îº â†’ submodule R A) 
  [graded_algebra ğ’œ] (w : Ïƒ â†’ Î¹) (Ï† : Î¹ â†’+ Îº) (f : Ïƒ â†’ A) 
  (h : âˆ€ s : Ïƒ, f s âˆˆ ğ’œ (Ï† (w s))) : 
  galg_hom.is_homogeneous' _ (weighted_homogeneous_submodule R w ) _ ğ’œ Ï†
    (mv_polynomial.aeval f) :=
begin
  intros i p hp,
  simp only [mem_weighted_homogeneous_submodule, is_weighted_homogeneous] at hp,
  rw p.as_sum,
  rw map_sum,
  apply submodule.sum_mem,
  intros c hc,
  rw aeval_monomial,
  rw â† smul_eq_mul, 
  rw algebra_map_smul,
  apply submodule.smul_mem, 
  convert finsupp.prod.mem_grade ğ’œ c f _ (Î» s _, h s ),
  rw â† hp (mem_support_iff.mp hc),
  simp only [weighted_degree'],
  rw finsupp.total,
  simp only [finsupp.coe_lsum, finsupp.sum],
  rw map_sum,
  simp only [linear_map.coe_smul_right, linear_map.id_coe, id.def, algebra.id.smul_eq_mul],
  apply congr_arg2 _ rfl,
  ext s,
  rw add_monoid_hom.map_nsmul,
end

end graded_algebra

lemma mv_polynomial.vars_X_subset {R : Type*} {Ïƒ : Type*} (n : Ïƒ) [comm_semiring R] :
  (X n : mv_polynomial Ïƒ R).vars âŠ† {n} := 
begin
  classical,
  intro u,
  rw [X, mem_vars, mem_singleton], 
  rintro âŸ¨c, hc, hc'âŸ©,
  by_contradiction h', 
  rw [mem_support_iff, coeff_monomial, ne.def] at hc, 
  by_cases h : finsupp.single n 1 = c,
  { rw [â† h, finsupp.mem_support_iff, ne.def, finsupp.single_apply] at hc',
    apply hc', rw if_neg (ne.symm h'), },
  { apply hc, rw if_neg h, },
end

section

open mv_polynomial 

variables {R M : Type*} [comm_ring R]

instance [decidable_eq R] [decidable_eq M] :
  graded_algebra (weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•)) := 
weighted_graded_algebra _ _

variable {R}
def degree (v : (â„• Ã— M) â†’â‚€ â„•) : â„• := finsum (Î» x, (v x) * x.1)

def is_homogeneous_of_degree (p : mv_polynomial (â„• Ã— M) R) (n : â„•) : Prop :=
âˆ€ v âˆˆ p.support, degree v = n

variable (R)

lemma variable_mem_supported (nm : â„• Ã— M) (hn : 0 < nm.1) :
  X nm âˆˆ supported R {nm : â„• Ã— M | 0 < nm.1} :=
begin
  rw mem_supported,
  refine set.subset.trans (finset.coe_subset.mpr (vars_X_subset nm)) _,
  rw [coe_singleton, set.singleton_subset_iff, set.mem_set_of_eq],
  exact hn,
end

def to_supported : mv_polynomial (â„• Ã— M) R â†’â‚[R] supported R {nm : â„• Ã— M | 0 < nm.1} :=  
aeval (Î» (nm : â„• Ã— M), dite (0 < nm.1) (Î» h, âŸ¨(X nm), (variable_mem_supported R nm h)âŸ©) (Î» h, 1))

lemma to_supported_is_homogeneous : 
  galg_hom.is_homogeneous' (mv_polynomial (â„• Ã— M) R)
    (weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•)) (mv_polynomial (â„• Ã— M) R)
    (weighted_homogeneous_submodule R prod.fst) (id : â„• â†’ â„•)
    ((subalgebra.val _).comp (to_supported R)) :=
begin
  classical,
  have h := @foo R _ (â„• Ã— M) â„• â„• _ _ _ (mv_polynomial (â„• Ã— M) R) _ _
  (weighted_homogeneous_submodule R prod.fst) _ prod.fst (add_monoid_hom.id â„•)
  ((subalgebra.val _).to_fun.comp (Î» (nm : â„• Ã— M), 
    dite (0 < nm.1) (Î» h, âŸ¨(X nm), (variable_mem_supported R nm h)âŸ©) (Î» h, 1))) _,
  have heq : (aeval ((supported R {nm : â„• Ã— M | 0 < nm.fst}).val.to_fun âˆ˜ 
    Î» (nm : â„• Ã— M), dite (0 < nm.fst) (Î» (h : 0 < nm.fst), âŸ¨X nm, _âŸ©) (Î» (h : Â¬0 < nm.fst), 1))) =
    ((supported R {nm : â„• Ã— M | 0 < nm.fst}).val.comp (to_supported R)),
  { apply mv_polynomial.alg_hom_ext,
    intros nm,
    simp only [to_supported, alg_hom.to_fun_eq_coe, function.comp_app, alg_hom.coe_comp, aeval_X] },
  rw heq at h,
  exact h,
  { intros nm,
    simp only [mem_weighted_homogeneous_submodule, alg_hom.to_fun_eq_coe, subalgebra.coe_val, 
      function.comp_app, add_monoid_hom.id_apply],
    split_ifs,
    { exact is_weighted_homogeneous_X R _ _, },
    { simp only [not_lt, le_zero_iff] at h,
      rw [h, algebra_map.coe_one],
      exact is_weighted_homogeneous_one R _, }}
end

variable (M)
-- TODO: generalize
lemma eq_finsupp_single_of_degree_one {d : â„• Ã— M â†’â‚€ â„•} (hd : (weighted_degree' prod.fst) d = 1)
  (hsupp : âˆ€ (nm : â„• Ã— M), nm âˆˆ d.support â†’ 0 < nm.fst) :
  âˆƒ (m : M), finsupp.single (1, m) 1 = d :=
begin
  classical,
  rw [weighted_degree', finsupp.total_apply, finsupp.sum] at hd,
  have hnm : âˆƒ (nm : â„• Ã— M), d nm â€¢ nm.fst = 1,
  { by_contra h0,
    rw [not_exists] at h0,
    have hd0 : d.support.sum (Î» (a : â„• Ã— M), d a â€¢ a.fst) = 0,
    { rw finset.sum_eq_zero,
      intros nm hnm,
      rw â† nat.lt_one_iff,
      apply lt_of_le_of_ne _ (h0 nm),
      rw â† hd,
      exact finset.single_le_sum (Î»ab hab,  zero_le _ ) hnm },
    rw [hd0] at hd,
    exact zero_ne_one hd, },
  obtain âŸ¨nm, hnmâŸ© := hnm,
  rw â† hnm at hd,
  rw [algebra.id.smul_eq_mul, nat.mul_eq_one_iff] at hnm,
  use nm.snd,
  ext ab,
  rw finsupp.single_apply,
  split_ifs with hab;
  rw [â† hnm.2, eq_comm, prod.mk.eta] at hab,
  { rw [hab, hnm.1], },
  { rw eq_comm,
    by_contra hab',
    have hne0 : d ab * ab.fst â‰  0,
    { exact mul_ne_zero hab' (ne_of_gt (hsupp ab (finsupp.mem_support_iff.mpr hab'))) },
    have hnm_mem : nm âˆˆ d.support,
    { rw [finsupp.mem_support_iff, hnm.1], exact one_ne_zero },
    simp only [finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self, 
      algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff, finsupp.mem_support_iff, --ne.def, 
      mem_singleton] at hd,
    exact hne0 (hd ab âŸ¨hab', habâŸ©) },
end

variables [add_comm_group M] [module R M]

namespace divided_power_algebra

-- We should probably change this name...

/-- The type coding the basic relations that will give rise to the divided power algebra. 
  The class of X (n, a) will be equal to dpow n a, with a âˆˆ M. --/
inductive rel : (mv_polynomial (â„• Ã— M) R) â†’ (mv_polynomial (â„• Ã— M) R) â†’ Prop 
  --rel (mv_polynomial (â„• Ã— M) R) (mv_polynomial (â„• Ã— M) R) Q : Why not use rel?
-- force `Î¹` to be linear and creates the divided powers
| zero {a : M} : rel (X (0, a)) 1
| smul {r : R} {n : â„•} {a : M} : rel (X (n, r â€¢ a)) (r^n â€¢ X (n, a))
| mul {m n : â„•} {a : M} : rel (X (m, a) * X (n, a)) ((nat.choose (m + n) m) â€¢ X (m + n, a))
| add {n : â„•} {a b : M} : rel (X (n, a + b)) 
    (finset.sum (range (n + 1)) (Î» k, (X (k, a) * X (n - k, b))))

/-- The ideal of mv_polynomial (â„• Ã— M) R generated by rel -/
def relI : ideal (mv_polynomial (â„• Ã— M) R) := of_rel (rel R M)

end divided_power_algebra

/-- The divided power algebra of a module M is the quotient of the polynomial ring
by the ring relation defined by divided_power_algebra.rel -/
@[protected, derive [inhabited, comm_ring, algebra R]]
def divided_power_algebra : Type* :=
 (mv_polynomial (â„• Ã— M) R) â§¸ (divided_power_algebra.relI R M)

namespace divided_power_algebra

/- Note that also we don't know yet that `divided_power_algebra R M` has divided powers, 
  it has a kind of universal property for morphisms to a ring with divided_powers -/

open mv_polynomial

/-- If `R` is a `k`-algebra, then `divided_power_algebra R M` inherits a `k`-algebra structure. -/
def algebra' (k : Type*) [comm_ring k] [algebra k R] : 
  algebra k (divided_power_algebra R M) :=
ring_hom.to_algebra (ring_hom.comp (algebra_map R (divided_power_algebra R M)) (algebra_map k R))

variables {R M}

lemma sub_mem_rel_of_rel {a b : mv_polynomial (â„• Ã— M) R} (h : rel R M a b) :  a - b âˆˆ relI R M :=
submodule.subset_span âŸ¨a, b, h, by rw [sub_add_cancel]âŸ©

variable (R)
/-- `dp R n m` is the equivalence class of `X (âŸ¨n, mâŸ©)` in `divided_power_algebra R M`. -/
def dp (n : â„•) (m : M) : divided_power_algebra R M :=
mkâ‚ R (relI R M) (X (âŸ¨n, mâŸ©))

--lemma dp_def (n : â„•) (m : M) : dp R n m = mkâ‚ R (relI R M) (X (âŸ¨n, mâŸ©)) := rfl  --rename?

lemma dp_eq_mkâ‚ (n : â„•) (m : M) : dp R n m = mkâ‚ R (relI R M) (X âŸ¨n, mâŸ©) := rfl

lemma dp_eq_mk (n : â„•) (m : M) : dp R n m = mk (relI R M) (X (âŸ¨n, mâŸ© : â„• Ã— M)) :=
by rw [dp, mkâ‚_eq_mk]

lemma dp_zero (m : M) : dp R 0 m = 1 :=
begin
  rw [dp, mkâ‚_eq_mk, â† map_one (ideal.quotient.mk (relI R M)), ideal.quotient.eq],
  exact submodule.subset_span âŸ¨X(0,m), 1, rel.zero, by rw sub_add_cancelâŸ©
end

lemma dp_smul (r : R) (n  : â„•) (m : M) : dp R n (r â€¢ m) = r ^ n â€¢ dp R n m :=
begin
  rw [dp, dp, â† map_smul, mkâ‚_eq_mk R, ideal.quotient.eq], 
  exact sub_mem_rel_of_rel rel.smul,
end

lemma dp_mul (n p : â„•) (m : M) : dp R n m * dp R p m = (n + p).choose n â€¢ dp R (n + p) m :=
begin
  simp only [dp, mkâ‚_eq_mk, â† _root_.map_mul, â† map_nsmul, ideal.quotient.eq], 
  exact sub_mem_rel_of_rel rel.mul,
end

lemma dp_add (n : â„•) (x y : M) : dp R n (x + y) = 
  (range (n+1)).sum (Î» k, dp R k x * dp R (n - k) y) := 
begin
  simp only [dp, mkâ‚_eq_mk, â† _root_.map_mul, â† map_sum, ideal.quotient.eq], 
  exact sub_mem_rel_of_rel rel.add,
end

lemma unique_on_dp {A : Type*} [comm_ring A] [algebra R A]
  {f g : divided_power_algebra R M â†’â‚[R] A} (h : âˆ€ n m, f (dp R n m) = g (dp R n m)) :
  f = g := 
begin
  rw fun_like.ext'_iff,
  apply function.surjective.injective_comp_right (quotient.mkâ‚_surjective R (relI R M)),
  simp only [â†  alg_hom.coe_comp, â† fun_like.ext'_iff], 
  exact alg_hom_ext (Î» âŸ¨n, mâŸ©, h n m)
end

section functoriality

variables (R M)

section lift

variables {A : Type*} [comm_ring A] [algebra R A]

/- General purpose lifting lemma -/
lemma lift_rel_le_ker (f : â„• Ã— M â†’ A) (hf_zero : âˆ€ m, f (0, m) = 1)
  (hf_smul : âˆ€ (n : â„•) (r : R) (m : M), f âŸ¨n, r â€¢ mâŸ© = r ^ n â€¢ f(âŸ¨n, mâŸ©)) 
  (hf_mul : âˆ€ n p m, f âŸ¨n, mâŸ© * f âŸ¨p, mâŸ© = ((n + p).choose n) â€¢ f âŸ¨n + p, mâŸ©)
  (hf_add : âˆ€ n u v, f âŸ¨n, u + vâŸ© = (range (n + 1)).sum (Î» (x : â„•), f âŸ¨x, uâŸ© * f âŸ¨n - x, vâŸ©)) :
  relI R M â‰¤ ring_hom.ker (@evalâ‚‚_alg_hom R A (â„• Ã— M) _ _ _ f) := 
begin
  rw [relI, of_rel, submodule.span_le],
  rintros x âŸ¨a, b, hx, habâŸ©,
  rw [eq_sub_iff_add_eq.mpr hab, set_like.mem_coe, ring_hom.mem_ker, map_sub, sub_eq_zero],
  induction hx with m r n m n p m n u v,
  { rw [evalâ‚‚_alg_hom_X', map_one, hf_zero] },
  { simp only [evalâ‚‚_alg_hom_X', alg_hom.map_smul, hf_smul] },
  { simp only [_root_.map_mul, evalâ‚‚_alg_hom_X', nsmul_eq_mul, map_nat_cast, hf_mul] },
  { simp only [coe_evalâ‚‚_alg_hom, evalâ‚‚_X, evalâ‚‚_sum, evalâ‚‚_mul, hf_add] },
end

/-- General purpose universal property of `divided_power_algebra R M` -/
def lift_aux (f : â„• Ã— M â†’ A) (hf_zero : âˆ€ m, f (0, m) = 1) 
  (hf_smul : âˆ€ (n : â„•) (r : R) (m : M), f âŸ¨n, r â€¢ mâŸ© = r ^ n â€¢ f(âŸ¨n, mâŸ©)) 
  (hf_mul : âˆ€ n p m, f âŸ¨n, mâŸ© * f âŸ¨p, mâŸ© = ((n + p).choose n) â€¢ f âŸ¨n + p, mâŸ©)
  (hf_add : âˆ€ n u v, f âŸ¨n, u + vâŸ© = (range (n + 1)).sum (Î» (x : â„•), f âŸ¨x, uâŸ© * f âŸ¨n - x, vâŸ©)) : 
  divided_power_algebra R M â†’â‚[R] A :=
liftâ‚ (relI R M) (evalâ‚‚_alg_hom R f) (lift_rel_le_ker R M f hf_zero hf_smul hf_mul hf_add)

lemma lift_aux_eq (f : â„• Ã— M â†’ A) (hf_zero : âˆ€ m, f (0, m) = 1) 
  (hf_smul : âˆ€ (n : â„•) (r : R) (m : M), f âŸ¨n, r â€¢ mâŸ© = r ^ n â€¢ f(âŸ¨n, mâŸ©)) 
  (hf_mul : âˆ€ n p m, f âŸ¨n, mâŸ© * f âŸ¨p, mâŸ© = ((n + p).choose n) â€¢ f âŸ¨n + p, mâŸ©)
  (hf_add : âˆ€ n u v, f âŸ¨n, u + vâŸ© = (range (n + 1)).sum (Î» (x : â„•), f âŸ¨x, uâŸ© * f âŸ¨n - x, vâŸ©)) 
  (p : mv_polynomial (â„• Ã— M) R) :
  lift_aux R M f hf_zero hf_smul hf_mul hf_add (mkâ‚ R (relI R M) p) = evalâ‚‚ (algebra_map R A) f p :=
by simp only [lift_aux, mkâ‚_eq_mk, liftâ‚_apply, lift_mk, alg_hom.coe_to_ring_hom, coe_evalâ‚‚_alg_hom]

lemma lift_aux_eq_X (f : â„• Ã— M â†’ A) (hf_zero : âˆ€ m, f (0, m) = 1) 
  (hf_smul : âˆ€ (n : â„•) (r : R) (m : M), f âŸ¨n, r â€¢ mâŸ© = r ^ n â€¢ f(âŸ¨n, mâŸ©)) 
  (hf_mul : âˆ€ n p m, f âŸ¨n, mâŸ© * f âŸ¨p, mâŸ© = ((n + p).choose n) â€¢ f âŸ¨n + p, mâŸ©)
  (hf_add : âˆ€ n u v, f âŸ¨n, u + vâŸ© = (range (n + 1)).sum (Î» (x : â„•), f âŸ¨x, uâŸ© * f âŸ¨n - x, vâŸ©))  
  (n : â„•) (m : M) :
  lift_aux R M f hf_zero hf_smul hf_mul hf_add (mkâ‚ R (relI R M) (X (n, m))) = f âŸ¨n, mâŸ© :=
by rw [lift_aux_eq, evalâ‚‚_X]

variables {I : ideal A} (hI : divided_powers I) (Ï† : M â†’â‚—[R] A) (hÏ† : âˆ€ m, Ï† m âˆˆ I)

/-- The â€œuniversalâ€ property of divided_power_algebra -/
def lift  : divided_power_algebra R M â†’â‚[R] A :=
lift_aux R M (Î» nm, hI.dpow nm.1 (Ï† nm.2)) (Î» m, hI.dpow_zero (hÏ† m)) 
  (Î» n r m, by rw [linear_map.map_smulâ‚›â‚—, ring_hom.id_apply, â† algebra_map_smul A r (Ï† m),
    smul_eq_mul, hI.dpow_smul n (hÏ† m), â† smul_eq_mul, â† map_pow, algebra_map_smul]) 
  (Î» n p m, by rw [hI.dpow_mul n p (hÏ† m), â† nsmul_eq_mul]) 
  (Î» n u v, by rw [map_add, hI.dpow_add n (hÏ† u) (hÏ† v)]) 

lemma lift_eqâ‚ (p : mv_polynomial (â„• Ã— M) R) : lift R M hI Ï† hÏ† (mkâ‚ R (relI R M) p) = 
  evalâ‚‚ (algebra_map R A) (Î» (nm : â„• Ã— M), hI.dpow nm.1 (Ï† nm.2)) p :=
by rw [lift, lift_aux_eq]

lemma lift_eq (p : mv_polynomial (â„• Ã— M) R) : lift R M hI Ï† hÏ† (mk (relI R M) p) = 
  evalâ‚‚ (algebra_map R A) (Î» (nm : â„• Ã— M), hI.dpow nm.1 (Ï† nm.2)) p :=
by rw [â† mkâ‚_eq_mk R, lift_eqâ‚]

lemma lift_eqâ‚_X (n : â„•) (m : M) :
  lift R M hI Ï† hÏ† (mkâ‚ R (relI R M) (X (n, m))) = hI.dpow n (Ï† m) :=
by rw [lift, lift_aux_eq_X]

lemma lift_eq_X (n : â„•) (m : M) :
  lift R M hI Ï† hÏ† (mk (relI R M) (X (n, m))) = hI.dpow n (Ï† m) :=
by rw [â† mkâ‚_eq_mk R, lift_eqâ‚_X]

end lift

section lift'

variables {M}

variables (S : Type*) [comm_ring S] [algebra R S] {N : Type*} [add_comm_group N] [module R N]
  [module S N] [is_scalar_tower R S N] [algebra R (divided_power_algebra S N)]
  [is_scalar_tower R S (divided_power_algebra S N)] (f : M â†’â‚—[R] N) 

lemma lift'_rel_le_ker :
  relI R M â‰¤ ring_hom.ker (@evalâ‚‚_alg_hom R _ (â„• Ã— M) _ _ _ (Î» nm, dp S nm.1 (f nm.2))) := 
begin
  apply rel_le_ker (relI R M) rfl,
  intros a b hab,
  induction hab with m r n m n p m n u v,
  { simp only [coe_evalâ‚‚_hom, evalâ‚‚_X, evalâ‚‚_one],
    rw dp_zero,  },
  { conv_rhs {rw [â† evalâ‚‚_alg_hom_apply, map_smul],},
    simp only [evalâ‚‚_alg_hom_apply, evalâ‚‚_hom_X', linear_map.map_smul],
    rw [â† algebra_map_smul S r, â† algebra_map_smul S (r ^ n), dp_smul, map_pow],
    apply_instance, apply_instance, },
  { simp only [coe_evalâ‚‚_hom, evalâ‚‚_mul, evalâ‚‚_X, nsmul_eq_mul], 
    simp only [evalâ‚‚_eq_eval_map, map_nat_cast, â† nsmul_eq_mul],
    rw dp_mul, },
  { simp only [map_add, coe_evalâ‚‚_hom, evalâ‚‚_sum, evalâ‚‚_mul, evalâ‚‚_X],
    rw dp_add, },
end

/-- The functoriality map between divided power algebras associated with a linear map of the
  underlying modules. Given an `R`-algebra `S`, an `S`-module `N` and `f : M â†’â‚—[R] N`, this is the
  map `divided_power_algebra R M â†’â‚[R] divided_power_algebra S N` that maps `X(n,m)` to `X(n, f m)`.
-/
def lift' : divided_power_algebra R M â†’â‚[R] divided_power_algebra S N := 
liftâ‚ (relI R M) _ (lift'_rel_le_ker R S f)

lemma lift'_eq (p : mv_polynomial (â„• Ã— M) R) : lift' R S f (mk (relI R M) p) = 
  evalâ‚‚ (algebra_map R (divided_power_algebra S N)) (Î» nm : â„• Ã— M, dp S nm.1 (f nm.2)) p := 
by simp only [lift', liftâ‚_apply, lift_mk, alg_hom.coe_to_ring_hom, coe_evalâ‚‚_alg_hom]

lemma lift'_eqâ‚ (p : mv_polynomial (â„• Ã— M) R) : lift' R S f (mkâ‚ R (relI R M) p) = 
  evalâ‚‚ (algebra_map R (divided_power_algebra S N)) (Î» nm : â„• Ã— M, dp S nm.1 (f nm.2)) p := 
by rw [mkâ‚_eq_mk, lift'_eq]

end lift'

end functoriality

section decidable_eq

variables (M) [decidable_eq R] [decidable_eq M]

lemma relI_is_homogeneous : 
  (relI R M).is_homogeneous ((weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•))) :=
begin
  apply is_homogeneous_span,
  rintros x âŸ¨a, b, h, hxâŸ©,
  rw eq_sub_iff_add_eq.mpr hx,
  induction h with n r n m n p m n u v,
  { exact âŸ¨0, submodule.sub_mem _ (is_weighted_homogeneous_X R _ _) 
      (is_weighted_homogeneous_one R _)âŸ© },
  { exact âŸ¨n, submodule.sub_mem _ (is_weighted_homogeneous_X R _ _) 
      (submodule.smul_mem _ _ (is_weighted_homogeneous_X R _ _))âŸ© },
  { exact âŸ¨n + p, submodule.sub_mem _ (is_weighted_homogeneous.mul (is_weighted_homogeneous_X R _ _)
      (is_weighted_homogeneous_X R _ _)) (nsmul_mem (is_weighted_homogeneous_X R _ _) _)âŸ© },
  { use n,
    refine submodule.sub_mem _ (is_weighted_homogeneous_X R _ _) (submodule.sum_mem _ _),
    intros c hc,
    have hnc : n = c + (n - c) := (nat.add_sub_of_le (finset.mem_range_succ_iff.mp hc)).symm, 
    nth_rewrite 1 hnc, 
    exact (is_weighted_homogeneous.mul (is_weighted_homogeneous_X R _ _)
      (is_weighted_homogeneous_X R _ _)) },
end

/-- The graded submodules of `divided_power_algebra R M` -/
def grade := quot_submodule R (weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•))
  (divided_power_algebra.relI R M)

lemma one_mem : (1 : divided_power_algebra R M) âˆˆ grade R M 0 :=
âŸ¨1, (is_weighted_homogeneous_one R _), rflâŸ©



/-- The canonical decomposition of `divided_power_algebra R M` -/
def decomposition := 
quot_decomposition R (weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•)) 
  (divided_power_algebra.relI R M) (relI_is_homogeneous R M)

end decidable_eq

end divided_power_algebra

/-- The graded algebra structure on the divided power algebra-/
def divided_power_galgebra [decidable_eq R] [decidable_eq M] :
  graded_algebra (divided_power_algebra.grade R M) := 
graded_quot_alg R (weighted_homogeneous_submodule R (prod.fst : â„• Ã— M â†’ â„•)) 
  (divided_power_algebra.relI R M) (divided_power_algebra.relI_is_homogeneous R M)

namespace divided_power_algebra

open mv_polynomial

section decidable_eq

variables (M) [decidable_eq R] [decidable_eq M]

-- Do we need both versions?
lemma dp_mem_grade (n : â„•) (m : M) : dp R n m âˆˆ grade R M n  :=
âŸ¨X (n, m), is_weighted_homogeneous_X R _ (n, m), rflâŸ©

lemma mkâ‚_mem_grade (n : â„•) (m : M) : (mkâ‚ R (relI R M)) (X (n, m)) âˆˆ grade R M n :=
âŸ¨X (n, m), is_weighted_homogeneous_X R _ (n, m), rflâŸ© 

/-- degree of a product is sum of degrees -/
lemma mul_mem â¦ƒi j : â„•â¦„ {gi gj : divided_power_algebra R M} (hi : gi âˆˆ grade R M i)
  (hj : gj âˆˆ grade R M j) : gi * gj âˆˆ grade R M (i + j) :=
(divided_power_galgebra R M).to_graded_monoid.mul_mem hi hj

def decompose : divided_power_algebra R M â†’ direct_sum â„• (Î» (i : â„•), â†¥(grade R M i)) :=
(divided_power_galgebra R M).to_decomposition.decompose'

/- graded_algebra (grade R M )-/
instance : graded_algebra (divided_power_algebra.grade R M) := 
divided_power_galgebra R M

end decidable_eq

variable {M}

variable (M)
lemma mkâ‚_comp_to_supported : 
  (mkâ‚ R (relI R M)).comp ((subalgebra.val _).comp (to_supported R)) = (mkâ‚ R _) :=
begin
  apply mv_polynomial.alg_hom_ext,
  rintro âŸ¨n,mâŸ©,
  simp only [alg_hom.coe_comp, mkâ‚_eq_mk, subalgebra.coe_val, function.comp_app, aeval_X,
    to_supported],
  split_ifs,
  { refl },
  { simp only [not_lt, le_zero_iff] at h,
    dsimp only [relI],
    rw [h, algebra_map.coe_one, quotient_mk_eq_of_rel rel.zero] },
end

variable {M}
lemma surjective_of_supported : function.surjective ((mkâ‚ R (relI R M)).comp 
  (subalgebra.val (supported R {nm : â„• Ã— M | 0 < nm.1 }))) := 
begin
  intro f, 
  obtain âŸ¨p',hp'âŸ© := mk_surjective f,
  use to_supported R p',
  rw [â† alg_hom.comp_apply, alg_hom.comp_assoc, mkâ‚_comp_to_supported, â† hp', mkâ‚_eq_mk],
end

lemma surjective_of_supported' [decidable_eq R] [decidable_eq M] {n : â„•} (p : grade R M n) :
  âˆƒ (q : supported R {nm : â„• Ã— M | 0 < nm.1 }), 
  is_weighted_homogeneous prod.fst q.1 n âˆ§ â‡‘(mk (relI R M)) q.1 = â†‘p :=
begin
  --intro f, 
  have hp := p.2,
  simp only [grade, quot_submodule, subtype.val_eq_coe, submodule.mem_map, 
    mem_weighted_homogeneous_submodule, mkâ‚_eq_mk] at hp,
  obtain âŸ¨p', hpn', hp'âŸ© := hp,
  use to_supported R p',
  split,
  { apply to_supported_is_homogeneous,
    exact hpn', },
  rw â† mkâ‚_eq_mk R,
  erw fun_like.congr_fun (mkâ‚_comp_to_supported R M) p', -- TODO: write mk_comp_to_supported
  rw mkâ‚_eq_mk R,
  rw hp',
  { apply_instance },
end

/-- The canonical linear map `M â†’â‚—[R] divided_power_algebra R M`. -/
def Î¹ : M â†’â‚—[R] (divided_power_algebra R M) :=
{ to_fun    := Î» m, dp R 1 m,
  map_add'  := Î» x y, by simp only [dp_add, sum_range_succ', sum_range_zero, zero_add, nat.sub_zero,
    nat.sub_self, dp_zero, mul_one, one_mul],
  map_smul' := Î» r x, by rw [dp_smul, pow_one, ring_hom.id_apply] }

lemma Î¹_def (m : M) : Î¹ R m = dp R 1 m := rfl

lemma mk_alg_hom_mv_polynomial_Î¹_eq_Î¹ (m : M) : mkâ‚ R (relI R M) (X (1, m)) = Î¹ R m := rfl

lemma mk_alg_hom_mv_polynomial_Î¹_eq_Î¹' (m : M) : dp R 1 m = Î¹ R m := rfl

@[simp] theorem Î¹_comp_lift {A : Type*} [comm_ring A] [algebra R A] {I : ideal A} 
  (hI : divided_powers I) (Ï† : M â†’â‚—[R] A) (hÏ† : âˆ€ m, Ï† m âˆˆ I) :
  (lift R M hI Ï† hÏ†).to_linear_map.comp (Î¹ R) = Ï† :=
begin
  ext,
  rw [linear_map.coe_comp, function.comp_app, alg_hom.to_linear_map_apply,
    â† mk_alg_hom_mv_polynomial_Î¹_eq_Î¹, lift_eqâ‚, evalâ‚‚_X],
  exact hI.dpow_one (hÏ† x),
end

@[simp] theorem lift_Î¹_apply {A : Type*} [comm_ring A] [algebra R A] {I : ideal A}
  (hI : divided_powers I) (Ï† : M â†’â‚—[R] A) (hÏ†: âˆ€ m, Ï† m âˆˆ I) (x) :
  lift R M hI Ï† hÏ† (Î¹ R x) = Ï† x :=
by { conv_rhs {rw â† Î¹_comp_lift R hI Ï† hÏ†,},refl, }

variables (M)



variable {R}
/-  [graded_algebra ğ’œ] --not used in this def -/
def has_graded_dpow {A : Type*} [comm_ring A] [algebra R A] (ğ’œ : â„• â†’ submodule R A)
  {I : ideal A} (hI : divided_powers I) := 
âˆ€ (a : A) (ha : a âˆˆ I) (i : â„•) (hai : a âˆˆ ğ’œ i) (n : â„•), hI.dpow n a âˆˆ ğ’œ (n â€¢ i)

section decidable_eq

variables (R) [decidable_eq R] [decidable_eq M]

lemma lift_aux_is_homogeneous {A : Type*} [comm_ring A] [algebra R A] (ğ’œ : â„• â†’ submodule R A) 
  [graded_algebra ğ’œ] (f : â„• Ã— M â†’ A) (hf_zero : âˆ€ m, f (0, m) = 1) 
  (hf_smul : âˆ€ (n : â„•) (r : R) (m : M), f(âŸ¨n, r â€¢ mâŸ©) = r ^ n â€¢ f(âŸ¨n, mâŸ©)) 
  (hf_mul : âˆ€ n p m, f (âŸ¨n, mâŸ©) * f (âŸ¨p, mâŸ©) = ((n + p).choose n) â€¢ f (âŸ¨n + p, mâŸ©))
  (hf_add : âˆ€ n u v, f (âŸ¨n, u + vâŸ©) = (range (n + 1)).sum (Î» (x : â„•), f (âŸ¨x, uâŸ©) * f (âŸ¨n - x, vâŸ©))) 
  (hf : âˆ€ n m, f (n, m) âˆˆ ğ’œ n) : 
  galg_hom.is_homogeneous (divided_power_algebra.grade R M) ğ’œ 
    (lift_aux R M f hf_zero hf_smul hf_mul hf_add) := 
begin
  intros i a ha,
  dsimp [grade, quot_submodule] at ha,
  obtain âŸ¨p, hp, rflâŸ© := ha, 
  rw [â† mkâ‚_eq_mk R, lift_aux_eq, p.as_sum, evalâ‚‚_sum],
  apply _root_.sum_mem,
  intros c hc, 
  rw [evalâ‚‚_monomial, â† smul_eq_mul, algebra_map_smul A],
  apply submodule.smul_mem, 
  rw â† hp (mem_support_iff.mp hc), 
  exact finsupp.prod.mem_grade _ _ _ _ (Î» âŸ¨n,mâŸ© hnm, hf n m),
  { apply_instance }, 
end

variable {R}
  
lemma lift_is_homogeneous {A : Type*} [comm_ring A] [algebra R A] (ğ’œ : â„• â†’ submodule R A) 
  [graded_algebra ğ’œ] {I : ideal A} (hI : divided_powers I) (hI' : has_graded_dpow ğ’œ hI)
  (Ï† : M â†’â‚—[R] A) (hÏ† : âˆ€ m, Ï† m âˆˆ I) (hÏ†' : âˆ€ m, Ï† m âˆˆ ğ’œ 1) : 
  galg_hom.is_homogeneous (divided_power_algebra.grade R M) ğ’œ (lift R M hI Ï† hÏ†) := 
begin
  apply lift_aux_is_homogeneous,
  intros n m,
  simpa only [algebra.id.smul_eq_mul, mul_one] using hI' (Ï† m) (hÏ† m) 1 (hÏ†' m) n
end

lemma lift'_is_homogeneous {N : Type*} [decidable_eq N] [add_comm_group N] [module R N] 
  (f : M â†’â‚—[R] N) :
  galg_hom.is_homogeneous (divided_power_algebra.grade R M) (divided_power_algebra.grade R N) 
    (lift' R R f) := 
begin
  apply lift_aux_is_homogeneous,
  { intro m, rw dp_zero},
  { intros n r m, rw [linear_map.map_smul, dp_smul] },
  { intros n p m, rw dp_mul }, 
  { intros n u v, rw [map_add, dp_add] },
  { intros n m, exact âŸ¨X(n, f m), âŸ¨is_weighted_homogeneous_X R _ _, rflâŸ©âŸ© },
end

/- We need the projections (divided_power_algebra R M) â†’ grade R M n ,
more generally for graded algebras -/

variable (R)

def proj' (n : â„•) : divided_power_algebra R M â†’â‚—[R] grade R M n := 
proj (grade R M) n

lemma proj'_zero_one : (proj' R M 0) 1 = 1 :=
by rw [proj', proj, linear_map.coe_mk, decompose_one]; refl

lemma proj'_zero_mul (x y : divided_power_algebra R M) : 
  (proj' R M 0) (x * y) = (proj' R M 0) x * (proj' R M 0) y :=
by simp only [proj', â† proj_zero_ring_hom'_apply, _root_.map_mul]

end decidable_eq 

instance : add_submonoid_class (submodule R (mv_polynomial (â„• Ã— M) R â§¸ relI R M))
  (divided_power_algebra R M) := 
submodule.add_submonoid_class

section grade_zero

variables (R)
def algebra_map_inv : divided_power_algebra R M â†’â‚[R] R :=
lift R M (divided_powers.of_square_zero.divided_powers (by rw [zero_eq_bot, pow_two, bot_mul]))
  (0 : M â†’â‚—[R] R) (Î» m, by simp only [linear_map.zero_apply, zero_eq_bot, mem_bot])

lemma algebra_map_inv_eq (f : mv_polynomial (â„• Ã— M) R) : 
  algebra_map_inv R M (mkâ‚ R (relI R M) f) = aeval (Î» nm : â„• Ã— M, ite (0 < nm.1) (0 : R) 1) f :=
begin
  rw â† alg_hom.comp_apply, 
  apply alg_hom.congr_fun,
  ext âŸ¨n, mâŸ©,
  simp only [algebra_map_inv, alg_hom.comp_apply, lift_eqâ‚, linear_map.zero_apply, aeval_X],
  by_cases hn : 0 < n,
  { rw [if_pos hn, evalâ‚‚_X, divided_powers.dpow_eval_zero _ (ne_of_gt hn)] },
  { rw if_neg hn,
    rw [not_lt, le_zero_iff] at hn,
    rw [hn, evalâ‚‚_X, divided_powers.dpow_zero _ (mem_bot.mpr rfl)] }
end

lemma proj'_zero_comp_algebra_map [decidable_eq R] [decidable_eq M] (x : R) :
  (((proj' R M 0) âˆ˜ (algebra_map R (divided_power_algebra R M))) x).val =
  ((algebra_map R (divided_power_algebra R M))) x :=
begin
  rw [function.comp_app, subtype.val_eq_coe, proj', proj, linear_map.coe_mk,
    algebra.algebra_map_eq_smul_one, decompose_smul, decompose_one, dfinsupp.coe_smul,
    pi.smul_apply, submodule.coe_smul_of_tower],
  refl,
end

-- variables (M) 
lemma algebra_map_left_inverse :
  function.left_inverse (algebra_map_inv R M) (algebra_map R (divided_power_algebra R M)) := 
Î» m, by simp only [alg_hom.commutes, algebra.id.map_eq_id, ring_hom.id_apply]

@[simp] lemma algebra_map_inj (x y : R) :
  algebra_map R (divided_power_algebra R M) x = algebra_map R (divided_power_algebra R M) y â†” 
  x = y :=
(algebra_map_left_inverse R M).injective.eq_iff

@[simp] lemma algebra_map_eq_zero_iff (x : R) : 
  algebra_map R (divided_power_algebra R M) x = 0 â†” x = 0 :=
map_eq_zero_iff (algebra_map _ _) (algebra_map_left_inverse _ _).injective

@[simp] lemma algebra_map_eq_one_iff (x : R) : 
  algebra_map R (divided_power_algebra R M) x = 1 â†” x = 1 :=
map_eq_one_iff (algebra_map _ _) (algebra_map_left_inverse _ _).injective

lemma mkâ‚_eq_aeval {C : Type*} [comm_ring C] {D : Type*} (I : ideal (mv_polynomial D C)) :
  (ideal.quotient.mkâ‚ C I) = aeval (Î» (d : D), ideal.quotient.mk I (X d)) :=
by ext d; simp only [mkâ‚_eq_mk, aeval_X]

lemma mk_eq_evalâ‚‚ {C : Type*} [comm_ring C] {D : Type*} (I : ideal (mv_polynomial D C)) :
  (ideal.quotient.mk I).to_fun  = evalâ‚‚ (algebra_map C ((mv_polynomial D C)â§¸ I)) 
  (Î» (d : D), ideal.quotient.mk I (X d)) :=
by ext d; simp_rw [ring_hom.to_fun_eq_coe, â† mkâ‚_eq_mk C, mkâ‚_eq_aeval, aeval_X]; refl

lemma algebra_map_right_inv_of_degree_zero [decidable_eq R] [decidable_eq M] (x : grade R M 0) :
  (algebra_map R (divided_power_algebra R M)) ((algebra_map_inv R M) x.1) = x.1 := 
begin
  have hx : x.val âˆˆ grade R M 0 := x.2,
  simp only [grade, quot_submodule, subtype.val_eq_coe, submodule.mem_map,
    mem_weighted_homogeneous_submodule, is_weighted_homogeneous] at hx,
  obtain âŸ¨p, hp0, hpxâŸ© := hx,
  rw [subtype.val_eq_coe, â† hpx, algebra_map_inv_eq, mkâ‚_eq_aeval, map_aeval, algebra.id.map_eq_id, 
    ring_hom_comp_triple.comp_eq, coe_evalâ‚‚_hom, aeval_def, p.as_sum, evalâ‚‚_sum, evalâ‚‚_sum, 
    finset.sum_congr rfl],
  intros exp hexp,
  have h : âˆ€ (nm : â„• Ã— M), nm âˆˆ exp.support â†’ nm.fst = 0,
  { intros nm hnm, 
    specialize hp0 (mem_support_iff.mp hexp),
    rw [weighted_degree', finsupp.total_apply, finsupp.sum, finset.sum_eq_zero_iff] at hp0,
    specialize hp0 nm hnm,
    rw [algebra.id.smul_eq_mul, nat.mul_eq_zero] at hp0,
    exact or.resolve_left hp0 (finsupp.mem_support_iff.mp hnm), },
  rw [evalâ‚‚_monomial, evalâ‚‚_monomial],
  apply congr_arg,
  rw finsupp.prod_congr,
  intros nm hnm,
  rw [if_neg, â† @prod.mk.eta _ _ nm, â† dp_eq_mk, h nm hnm, dp_zero, map_one],
  { rw [h nm hnm], exact lt_irrefl 0, },
end

/-- An ideal J of a commutative ring A is an augmentation ideal
if ideal.quotient.mk J has a right inverse which is a ring_hom -/
def is_augmentation_ideal (A : Type*) [comm_ring A] (J : ideal A) : Prop :=
âˆƒ g : Aâ§¸J â†’+* A, (ideal.quotient.mk J) âˆ˜ g = id

/-- The augmentation ideal in the divided_power_algebra -/
def aug_ideal : ideal (divided_power_algebra R M) := ring_hom.ker (algebra_map_inv R M)

lemma mem_aug_ideal_iff (f : divided_power_algebra R M) : 
  f âˆˆ aug_ideal R M â†” algebra_map_inv R M f = 0 :=
by rw [aug_ideal, ring_hom.mem_ker]

/-- The image of Î¹ is contained in the augmentation ideal -/
lemma Î¹_mem_aug_ideal (m : M) : (Î¹ R) m âˆˆ aug_ideal R M :=
by simp only [mem_aug_ideal_iff, Î¹, dp, linear_map.coe_mk, algebra_map_inv_eq, aeval_X, 
  nat.lt_one_iff, eq_self_iff_true, if_true]

/- We prove that the augmentation is an augmentation ideal, namely there is a section -/
lemma aug_ideal_is_augmentation_ideal : 
  is_augmentation_ideal (divided_power_algebra R M) (aug_ideal R M) :=
begin
  let g := ker_lift_alg (algebra_map_inv R M),
  let g1 := algebra_map R (divided_power_algebra R M â§¸ aug_ideal R M),
  use (algebra_map R (divided_power_algebra R M)).comp g.to_ring_hom,
  ext x,
  rw [ker_lift_alg_to_ring_hom, ring_hom.coe_comp, function.comp_app, mk_algebra_map, id.def],
  suffices h_inv : function.right_inverse g g1, 
  { exact h_inv x },
  refine function.right_inverse_of_injective_of_left_inverse
   (ring_hom.ker_lift_injective _) _,
  intro r, 
  rw [alg_hom_class.commutes, algebra.id.map_eq_id, ring_hom.id_apply]
end 

-- Q : if algebra map has a section, is the kernel an augmentation ideal?

lemma coeff_zero_of_mem_aug_ideal {f : mv_polynomial (â„• Ã— M) R}
  (hf : f âˆˆ supported R {nm : â„• Ã— M | 0 < nm.fst}) (hf0 : (mk (relI R M)) f âˆˆ aug_ideal R M) : 
  coeff 0 f = 0 :=
begin
  rw [aug_ideal, ring_hom.mem_ker] at hf0,
  rw [â† hf0, â† mkâ‚_eq_mk R _, algebra_map_inv_eq R M, eq_comm],
  conv_lhs { rw [f.as_sum, map_sum] },
  convert @finset.sum_eq_single _ _ _ (f.support) _ 0 _ _,
  { rw [monomial_zero', aeval_C, algebra.id.map_eq_id, ring_hom.id_apply], },
  { intros b hb hb0,
    rw [aeval_monomial, algebra.id.map_eq_id, ring_hom.id_apply],
    convert mul_zero _,
    obtain âŸ¨i, hiâŸ© := finsupp.support_nonempty_iff.mpr hb0,  
    rw finsupp.prod, 
    apply finset.prod_eq_zero hi,
    have hi' : 0 < i.fst,
    { apply mem_supported.mp hf,
      rw [finset.mem_coe, mem_vars],
      exact âŸ¨b, âŸ¨hb, hiâŸ©âŸ© },
    rw if_pos hi',
    exact zero_pow (zero_lt_iff.mpr (finsupp.mem_support_iff.mp hi)) },
  { intro hf',
    rw [monomial_zero', aeval_C, algebra.id.map_eq_id, ring_hom.id_apply,
      â† not_mem_support_iff.mp hf'] }
end  

lemma aug_ideal_eq_span :
  span (set.image (Î» nm, mk _ (X nm)) { nm : â„• Ã— M | 0 < nm.1 }) = aug_ideal R M := 
begin
  classical,
  apply le_antisymm,
  { rw span_le, 
    intros f,
    simp only [mk_eq_mk, set.mem_image, set.mem_set_of_eq, prod.exists, exists_and_distrib_left, 
      set_like.mem_coe, forall_exists_index, and_imp],
    intros n hn m hf, 
    rw [â† hf, aug_ideal, ring_hom.mem_ker, algebra_map_inv, lift_eq],
    simp_rw linear_map.zero_apply,
    rw [evalâ‚‚_X, divided_powers.dpow_eval_zero _ (ne_of_gt hn)] },
  { intros f0 hf0,
    obtain âŸ¨âŸ¨f, hfâŸ©, rflâŸ© := divided_power_algebra.surjective_of_supported R f0,
    have hf0' : coeff 0 f = 0 := coeff_zero_of_mem_aug_ideal R M hf hf0,
    simp only [alg_hom.coe_comp, mkâ‚_eq_mk, subalgebra.coe_val, function.comp_app, 
      set_like.coe_mk] at hf0 âŠ¢,
    rw [set.image_comp, â† map_span (mk (relI R M)), f.as_sum],
    apply ideal.mem_map_of_mem _ (sum_mem _ _),
    intros c hc, 
    rw [monomial_eq, finsupp.prod],
    refine mul_mem_left _ _ _,
    suffices supp_ss : â†‘(c.support) âŠ† {nm : â„• Ã— M | 0 < nm.fst},
    { by_cases hc0 : c.support.nonempty,
      { obtain âŸ¨nm, hnmâŸ© := hc0,
        rw finset.prod_eq_mul_prod_diff_singleton hnm,
        apply mul_mem_right _ _ 
          (pow_mem_of_mem _ _ _ (nat.pos_of_ne_zero (finsupp.mem_support_iff.mp hnm))),
        exact subset_span âŸ¨nm, âŸ¨(supp_ss hnm), rflâŸ©âŸ© }, 
      { -- cas oÃ¹ c.support est vide : c = 0 ; contradiction
        rw [not_nonempty_iff_eq_empty, finsupp.support_eq_empty] at hc0,
        rw hc0 at hc, 
        exact absurd hf0' (mem_support_iff.mp hc) }},
    { -- supp_ss
      intros nm hnm, 
      apply mem_supported.mp hf, 
      simp only [mem_vars, mem_coe, mem_support_iff, ne.def, finsupp.mem_support_iff, exists_prop],
      rw [mem_coe, finsupp.mem_support_iff] at hnm,
      exact âŸ¨c,âŸ¨mem_support_iff.mp hc, hnmâŸ©âŸ© }}, 
end

lemma right_inv' [decidable_eq R] [decidable_eq M] (x : R) :
  (algebra_map_inv R M) (((proj' R M 0) âˆ˜ (algebra_map R (divided_power_algebra R M))) x).val = x :=
by rw proj'_zero_comp_algebra_map; exact algebra_map_left_inverse R M x

lemma left_inv' [decidable_eq R] [decidable_eq M] (x : grade R M 0) :
  ((proj' R M 0) âˆ˜ (algebra_map R (divided_power_algebra R M))) ((algebra_map_inv R M) x.val) = x :=
begin
  ext,
  simp only [proj', proj, linear_map.coe_mk, function.comp_app], 
  conv_rhs { rw [â† subtype.val_eq_coe, â† direct_sum.decompose_of_mem_same _ x.2] },
  rw algebra_map_right_inv_of_degree_zero R M x,
end

/- grade R M 0 â†’ R is isomorphism -/
noncomputable! def ring_equiv_degree_zero [decidable_eq R] [decidable_eq M] :
  ring_equiv (grade R M 0) R := 
{ to_fun    := Î» x, algebra_map_inv R M x.1,
  inv_fun   := (proj' R M 0) âˆ˜ (algebra_map R (divided_power_algebra R M)),
  left_inv  := left_inv' R M,
  right_inv := right_inv' R M,
  map_mul'  := Î» x y, by rw â† _root_.map_mul; refl,
  map_add'  := Î» x y, by rw â† _root_.map_add; refl, }

def proj_0_ring_hom [decidable_eq R] [decidable_eq M] : ring_hom (divided_power_algebra R M) R :=
{ to_fun    := (ring_equiv_degree_zero R M).to_fun âˆ˜ (proj' R M 0),
  map_one'  := by rw [ring_equiv.to_fun_eq_coe, mul_equiv_class.map_eq_one_iff, proj'_zero_one],
  map_mul'  := Î»x y, by rw [ring_equiv.to_fun_eq_coe, function.comp_app, â† _root_.map_mul, 
    proj'_zero_mul],
  map_zero' := by simp only [ring_equiv.to_fun_eq_coe, function.comp_app, map_zero],
  map_add'  := by simp only [ring_equiv.to_fun_eq_coe, function.comp_app, map_add, 
    eq_self_iff_true, forall_const] }

end grade_zero

section grade_one

variable (R)
/-- The canonical map from `divided_power_algebra R M` into `triv_sq_zero_ext R M` that sends
`divided_power_algebra.Î¹` to `triv_sq_zero_ext.inr`. -/
def to_triv_sq_zero_ext [module Ráµáµ’áµ– M] [is_central_scalar R M] :
  divided_power_algebra R M â†’â‚[R] triv_sq_zero_ext R M :=
lift R M (divided_powers.of_square_zero.divided_powers (triv_sq_zero_ext.square_zero R M) :
  divided_powers (ker_ideal R M)) (inr_hom R M) (Î» m, (mem_ker_ideal_iff_exists R M _).mpr âŸ¨m, rflâŸ©)

@[simp] lemma to_triv_sq_zero_ext_Î¹ [module Ráµáµ’áµ– M] [is_central_scalar R M] (x : M) :
   to_triv_sq_zero_ext R M (Î¹ R x) = inr x :=
lift_Î¹_apply R _ _ _ x

@[simp] lemma to_triv_sq_zero_ext_snd [module Ráµáµ’áµ– M] [is_central_scalar R M] (m : M) :
  ((to_triv_sq_zero_ext R M) ((mkâ‚ R (relI R M)) (X (1, m)))).snd = m :=
by rw [â† dp_eq_mkâ‚, â† Î¹_def, to_triv_sq_zero_ext_Î¹]; refl
.

lemma deg_one_left_inv [decidable_eq R] [decidable_eq M] [module Ráµáµ’áµ– M] [is_central_scalar R M] :
  function.left_inverse (Î» (x : (grade R M 1)), (to_triv_sq_zero_ext R M x.1).snd) 
    ((proj' R M 1) âˆ˜ (Î¹ R)) :=
begin
  intros m,
  simp only [function.comp_app, subtype.val_eq_coe, Î¹, dp, proj', proj, linear_map.coe_mk],
  rw â† triv_sq_zero_ext.snd_inr R m, 
  apply congr_arg,
  rw [snd_inr, â† to_triv_sq_zero_ext_Î¹, Î¹, linear_map.coe_mk, dp, 
    decompose_of_mem_same _ (mkâ‚_mem_grade R M 1 m)],
end

/- -- TODO: move; generalize
lemma eq_finsupp_single_of_degree_one {d : â„• Ã— M â†’â‚€ â„•} (hd : (weighted_degree' prod.fst) d = 1)
  (hsupp : âˆ€ (nm : â„• Ã— M), nm âˆˆ d.support â†’ 0 < nm.fst) :
  âˆƒ (m : M), finsupp.single (1, m) 1 = d :=
begin
  classical,
  rw [weighted_degree', finsupp.total_apply, finsupp.sum] at hd,
  have hnm : âˆƒ (nm : â„• Ã— M), d nm â€¢ nm.fst = 1,
  { by_contra h0,
    rw [not_exists] at h0,
    have hd0 : d.support.sum (Î» (a : â„• Ã— M), d a â€¢ a.fst) = 0,
    { rw finset.sum_eq_zero,
      intros nm hnm,
      rw â† nat.lt_one_iff,
      apply lt_of_le_of_ne _ (h0 nm),
      rw â† hd,
      exact finset.single_le_sum (Î»ab hab,  zero_le _ ) hnm },
    rw [hd0] at hd,
    exact zero_ne_one hd, },
  obtain âŸ¨nm, hnmâŸ© := hnm,
  rw â† hnm at hd,
  rw [algebra.id.smul_eq_mul, nat.mul_eq_one_iff] at hnm,
  use nm.snd,
  ext ab,
  rw finsupp.single_apply,
  split_ifs with hab;
  rw [â† hnm.2, eq_comm, prod.mk.eta] at hab,
  { rw [hab, hnm.1], },
  { rw eq_comm,
    by_contra hab',
    have hne0 : d ab * ab.fst â‰  0,
    { exact mul_ne_zero hab' (ne_of_gt (hsupp ab (finsupp.mem_support_iff.mpr hab'))) },
    have hnm_mem : nm âˆˆ d.support,
    { rw [finsupp.mem_support_iff, hnm.1], exact one_ne_zero },
    simp only [finset.sum_eq_sum_diff_singleton_add hnm_mem, add_left_eq_self, 
      algebra.id.smul_eq_mul, sum_eq_zero_iff, mem_sdiff, finsupp.mem_support_iff, --ne.def, 
      mem_singleton] at hd,
    exact hne0 (hd ab âŸ¨hab', habâŸ©) },
end -/

theorem grade_one_eq_span {R M : Type*} [comm_ring R] [add_comm_group M]
  [module R M] [decidable_eq R] [decidable_eq M] : 
  grade R M 1 = submodule.span R (set.range (dp R 1)) := 
begin
  apply le_antisymm,
  { intros p hp,
    obtain âŸ¨q, hq1, hqpâŸ© := surjective_of_supported' R âŸ¨p, hpâŸ©,
    rw [subtype.val_eq_coe, submodule.coe_mk] at hqp,
    rw [is_weighted_homogeneous, subtype.val_eq_coe] at hq1,
    rw [â† hqp, â† mkâ‚_eq_mk R, (q : mv_polynomial (â„• Ã— M) R).as_sum, map_sum],
    apply submodule.sum_mem (submodule.span R (set.range (dp R 1))),
    intros d hd,
    have hsupp : âˆ€ (nm : â„• Ã— M), nm âˆˆ d.support â†’ 0 < nm.fst,
    { intros nm hnm,
      apply mem_supported.mp q.2,
      rw [subtype.val_eq_coe, mem_coe, mem_vars],
      exact âŸ¨d, hd, hnmâŸ©, },
    obtain âŸ¨m, hmâŸ© := eq_finsupp_single_of_degree_one M (hq1 (mem_support_iff.mp hd)) hsupp,
    rw [â† hm, monomial_eq, C_mul', map_smul, finsupp.prod_single_index, pow_one],
    exact submodule.smul_mem (submodule.span R (set.range (dp R 1))) _ 
      (submodule.subset_span (set.mem_range.mpr âŸ¨m, rflâŸ©)),
    { rw pow_zero}, },
  { rw submodule.span_le,
    intros p hp,
    obtain âŸ¨m, hmâŸ© := set.mem_range.mp hp,
    rw â† hm,
    exact dp_mem_grade R M 1 m, }
end

theorem grade_one.induction_on {R M : Type*} [comm_ring R] [add_comm_group M]
  [module R M] [decidable_eq R] [decidable_eq M] {P : grade R M 1 â†’ Prop} 
  (p : grade R M 1) (h_X : âˆ€ (m : M) (r : R), P (r â€¢ âŸ¨dp R 1 m, dp_mem_grade R M 1 mâŸ©)) 
  (h_add : âˆ€ (p q : grade R M 1), P p â†’ P q â†’ P (p + q)) :
  P p :=
begin
  obtain âŸ¨q, hq1, hqpâŸ© := surjective_of_supported' R p,

  have hq_fst : âˆ€ (nm : â„• Ã— M), nm âˆˆ q.1.vars â†’ nm.fst = 1,
  { intros nm hnm,
    simp only [vars, degrees, sup_to_finset, finsupp.to_finset_to_multiset, finset.mem_sup] at hnm,
    obtain âŸ¨d, hd, hdnmâŸ© := hnm,
    have hd' : âˆ€ (ab : â„• Ã— M), ab âˆˆ d.support â†’ 0 < ab.fst, --TODO: extract to lemma
    { intros ab hab,
      have hq2 := q.2,
      simp only [mem_supported] at hq2,
      sorry },
    specialize hq1 (mem_support_iff.mp hd),
    rw [weighted_degree', finsupp.total_apply, finsupp.sum] at hq1,
    obtain âŸ¨m, hmâŸ© := eq_finsupp_single_of_degree_one M hq1 hd',
    rw [â† hm] at hdnm,
    simp only [finsupp.mem_support_iff, ne.def] at hdnm,
    rw finsupp.single_apply at hdnm,
    simp only [ite_eq_right_iff, nat.one_ne_zero, not_forall, not_false_iff, exists_prop, 
      and_true] at hdnm,
    rw â† hdnm },

  have hp : âˆƒ (s : finset M), 
    p = s.sum (Î» m, (coeff (finsupp.single (1, m) 1) q.1) â€¢ âŸ¨dp R 1 m, dp_mem_grade R M 1 mâŸ©),
  { set s : finset M := finset.image (Î» (nm : â„• Ã— M) , nm.snd) q.1.vars with hs,
    use s,
    ext,
    rw [hs, finset.sum_image (Î» nm hnm nm' hnm' heq, 
      prod.ext_iff.mpr âŸ¨by rw [hq_fst nm hnm, hq_fst nm' hnm'], heqâŸ©), â† hqp],
    simp only [dp_eq_mkâ‚, mkâ‚_eq_mk, subtype.val_eq_coe, submodule.coe_sum, set_like.mk_smul_mk, 
      submodule.coe_mk, â† ideal.quotient.mk_eq_mk, â† submodule.quotient.mk_smul, 
      mv_polynomial.smul_eq_C_mul],
    simp only [mk_eq_mk, â† map_sum],
    apply congr_arg,
    ext d,
    simp only [coeff_sum, coeff_C_mul],
    by_cases hd : âˆƒ m, finsupp.single (1, m) 1 = d,
    { obtain âŸ¨m, hmdâŸ© := hd, 
      rw finset.sum_eq_single (1, m),
      { rw [â† hmd, coeff_X, mul_one] },
      { intros nm hnm hnm1,
        rw [â† hmd, coeff_X', if_neg, mul_zero],
        { simp only [finsupp.single_eq_single_iff, prod.mk.inj_iff, eq_self_iff_true, true_and, 
            and_true, nat.one_ne_zero, and_self, or_false],
          rw [ne.def, prod.eq_iff_fst_eq_snd_eq, hq_fst nm hnm, eq_self_iff_true, 
            true_and] at hnm1,
          exact hnm1 }},
      { intros hm_vars,
        simp only [mem_vars, not_exists] at hm_vars,
        have h_coeff : coeff (finsupp.single (1, (1, m).snd) 1) (â†‘q : mv_polynomial _ R) = 0,
        { by_contra hne0,
          rw [â† ne.def, â† mem_support_iff] at hne0,
          specialize hm_vars _ hne0,
          rw [finsupp.mem_support_iff, finsupp.single_eq_same] at hm_vars,
          exact hm_vars nat.one_ne_zero },
        rw [h_coeff, zero_mul] }},
    { have hq0 : coeff d (â†‘q : mv_polynomial _ R) = 0,
      { have hd' : âˆ€ (ab : â„• Ã— M), ab âˆˆ d.support â†’ 0 < ab.fst,
      { intros ab hab,
        sorry },
        rw is_weighted_homogeneous at hq1,
        simp_rw not_imp_comm at hq1,
        apply hq1,
        intros h,
        exact hd (eq_finsupp_single_of_degree_one M h hd') },
      rw [hq0, eq_comm],
      apply finset.sum_eq_zero,
      intros nm hnm,
      rw [mv_polynomial.coeff_X', if_neg, mul_zero],
      { rw [not_exists] at hd, exact hd nm.snd }}},
  obtain âŸ¨s, hspâŸ© := hp,
  rw hsp,
  refine finset.sum_induction _ _ h_add _ (Î» m hm, h_X m _),
  { convert h_X 0 0, rw zero_smul }
end

lemma deg_one_right_inv [decidable_eq R] [decidable_eq M] [module Ráµáµ’áµ– M] [is_central_scalar R M] :
  function.right_inverse (Î» (x : (grade R M 1)), (to_triv_sq_zero_ext R M x.1).snd) --try with snd_hom , submodule.val
    ((proj' R M 1) âˆ˜ (Î¹ R)) :=
begin
  --rw function.right_inverse_iff_comp,
  --rw â† linear_map.coe_comp,
  --simp only [linear_map.coe_comp, subtype.val_eq_coe, snd_hom_apply],
  --simp only [subtype.val_eq_coe],
  --apply linear_map.ext_on,
  intros x,
  apply grade_one.induction_on x,
  { intros m r,
    ext,
    simp only [proj', proj, linear_map.coe_mk, function.comp_app, Î¹, dp,
      set_like.mk_smul_mk, alg_hom.map_smul, snd_smul, submodule.coe_mk],
    rw [decompose_of_mem_same _ (mkâ‚_mem_grade R M 1 _),
      to_triv_sq_zero_ext_snd, â† alg_hom.map_smul],
    rw [mkâ‚_eq_mk, ideal.quotient.eq],
    apply sub_mem_rel_of_rel,
    convert rel.smul,
    rw pow_one  },
  { intros y z hy hz,
    simp only [subtype.val_eq_coe, function.comp_app] at hy hz,
    have hyz : (y + z).val = y.val + z.val := rfl,
    simp only [hyz, function.comp_app],
    simp only [subtype.val_eq_coe, snd_add, map_add, hy, hz] }
end

/- Î¹ : M â†’ grade R M 1 is isomorphism -/
def linear_equiv_degree_one [decidable_eq R] [decidable_eq M] [module Ráµáµ’áµ– M]
  [is_central_scalar R M] :  linear_equiv (ring_hom.id R) M (grade R M 1) :=
{ to_fun    := (proj' R M 1) âˆ˜ Î¹ R,
  inv_fun   := Î» x, (to_triv_sq_zero_ext R M x.1).snd, 
  map_add'  := Î» x y, by simp only [function.comp_app, map_add],
  map_smul' := Î» r x, by simp only [function.comp_app, linear_map.map_smulâ‚›â‚—, ring_hom.id_apply],
  left_inv  := deg_one_left_inv R M,
  right_inv := deg_one_right_inv R M }

end grade_one

variables (x : M) (n : â„•)

/-- Lemma 2 of Roby 65. -/
lemma on_dp_algebra_unique (h h' : divided_powers (aug_ideal R M))
  (h1 : âˆ€ (x : M) (n : â„•), h.dpow n (Î¹ R x) = mk _ (X (n, x)))
  (h1' : âˆ€ (x : M) (n : â„•), h'.dpow n (Î¹ R x) = mk _ (X (n, x))) : h = h' := 
begin
  apply divided_powers.dp_uniqueness h h' (aug_ideal_eq_span R M),
  rintros n f âŸ¨âŸ¨q, mâŸ©, hq, rflâŸ©,
  simp only [set.mem_set_of_eq] at hq,
  simp only,
  nth_rewrite 0 [â† h1 m q],
  rw [â† h1' m q, h.dpow_comp n (ne_of_gt hq) (Î¹_mem_aug_ideal R M m), 
    h'.dpow_comp n (ne_of_gt hq) (Î¹_mem_aug_ideal R M m), h1 m,  h1' m],
end

def cond_D : Prop := âˆƒ (h : divided_powers (aug_ideal R M)), 
  âˆ€ (x : M) (n : â„•), h.dpow n (Î¹ R x) = submodule.quotient.mk (X (n, x))

end divided_power_algebra

end

section roby
/- Formalization of Roby 1965, section 8 -/

open_locale tensor_product

variables (A R S : Type*) [comm_ring A] [comm_ring R] [algebra A R] [comm_ring S] [algebra A S] 
  {I : ideal R} {J : ideal S} (hI : divided_powers I) (hJ : divided_powers J)

def i_1 : R â†’â‚ R âŠ—[A] S := algebra.tensor_product.include_left

def i_2 : S â†’â‚ R âŠ—[A] S := algebra.tensor_product.include_right

variables {R S} (I J)
def K : ideal (R âŠ—[A] S) := (I.map (i_1 A R S)) âŠ” (J.map (i_2 A R S))

namespace divided_powers

variables {I J}
/- Lemma 1 : uniqueness of the dp structure on R âŠ— S for I + J -/
lemma on_tensor_product_unique (hK hK' : divided_powers (K A I J))
  (hIK : is_pd_morphism hI hK (i_1 A R S)) (hIK' : is_pd_morphism hI hK' (i_1 A R S))
  (hJK : is_pd_morphism hJ hK (i_2 A R S)) (hJK' : is_pd_morphism hJ hK' (i_2 A R S)) : 
  hK = hK' :=
begin
  apply eq_of_eq_on_ideal,
  intros n x hx,
  suffices : x âˆˆ sub_pd_ideal.pd_equalizer hK hK',  
  { exact ((sub_pd_ideal.mem_pd_equalizer_iff _ _).mp this).2 n,},
  suffices h_ss : K A I J â‰¤ sub_pd_ideal.pd_equalizer hK hK',
  { exact h_ss hx },
  dsimp only [K], 
  rw sup_le_iff,
  split,
  apply sub_pd_ideal.le_equalizer_of_pd_morphism hI (i_1 A R S).to_ring_hom
    le_sup_left hK hK' hIK hIK',
  apply sub_pd_ideal.le_equalizer_of_pd_morphism hJ (i_2 A R S).to_ring_hom
    le_sup_right hK hK' hJK hJK',
end

def cond_T : Prop :=
âˆƒ hK : divided_powers (K A I J), 
  is_pd_morphism hI hK (i_1 A R S) âˆ§ is_pd_morphism hJ hK (i_2 A R S)

section free

-- hR_free, hS_free are not used for the def (they might be needed at lemmas about cond_T_free)
def cond_T_free /- [hR_free : module.free A R] [hS_free : module.free A S]  -/: Prop :=
âˆƒ hK : divided_powers (K A I J), 
  is_pd_morphism hI hK (i_1 A R S) âˆ§ is_pd_morphism hJ hK (i_2 A R S)

def cond_Q (A R : Type*) [comm_ring A] [comm_ring R] /- [algebra A R] not used -/
  {I : ideal R} (hI : divided_powers I) : Prop := 
âˆƒ (T : Type*) [comm_ring T], by exactI âˆƒ [algebra A T], by exactI âˆƒ [module.free A T]
  {J : ideal T} (hJ : divided_powers J) (f : pd_morphism hI hJ), 
  function.surjective f.to_ring_hom

end free

end divided_powers

end roby

section divided_power_algebra

/- 
and a divided power structure on that ideal such that
dpow R n (Î¹ R x) = mk_alg_hom R (rel R M) (X (x, n)) 

(x,n) represents dpow n x
dpow m (x,n) should be dpow m (dpow n x) = (mchoose m n) dpow (m*n) x
An element x in divided_power_algebra R M takes the form
mk_alg_hom R (rel R M) (P)
where P is a sum of monomials  a * (m,n)   : m âˆˆ M, n âˆˆ â„•
define
dpow k x = sum products a ^ káµ¢ * dpow (mchoose káµ¢ náµ¢ (máµ¢,náµ¢ * káµ¢)) 
where the sum is over functions â†’ â„•, with sum k
-/

/- Prove that it is uniqueâ€¦ -/


/- Introduce notation ?
Here : x ^ [n] = mk_alg_hom R _ (X (x, n))
In general, x ^ [n]  for dpow n x ? 

-/

end divided_power_algebra

#lint