/- Copyright 2022 ACL & MIdFF-/

-- import algebra.free_algebra
import algebra.ring_quot
-- import algebra.triv_sq_zero_ext
import algebra.algebra.operations
-- import linear_algebra.multilinear.basic

-- import ring_theory.graded_algebra.basic
-- import ring_theory.tensor_product
-- import data.mv_polynomial.supported

import data.rel

import divided_powers.basic
-- import divided_powers.sub_pd_ideal
-- import divided_powers.rat_algebra
-- import divided_powers.ideal_add
import divided_powers.dp_algebra.misc
-- import ..weighted_homogeneous -- Modified version of PR #17855
-- import ..graded_ring_quot -- Quotients of graded rings
-- import ..graded_module_quot

noncomputable theory

open finset mv_polynomial ideal.quotient 
-- triv_sq_zero_ext 
open ideal 
-- direct_sum 
open ring_quot

/-! 
The divided power algebra of a module -/

section

variables (R M : Type*) [comm_ring R] [add_comm_group M] [module R M]

namespace divided_power_algebra

--open finset mv_polynomial ideal.quotient triv_sq_zero_ext ideal direct_sum ring_quot

-- We should probably change this name...

/-- The type coding the basic relations that will give rise to the divided power algebra. 
  The class of X (n, a) will be equal to dpow n a, with a ∈ M. --/
inductive rel : (mv_polynomial (ℕ × M) R) → (mv_polynomial (ℕ × M) R) → Prop 
  --rel (mv_polynomial (ℕ × M) R) (mv_polynomial (ℕ × M) R) Q : Why not use rel?
-- force `ι` to be linear and creates the divided powers
| zero {a : M} : rel (X (0, a)) 1
| smul {r : R} {n : ℕ} {a : M} : rel (X (n, r • a)) (r^n • X (n, a))
| mul {m n : ℕ} {a : M} : rel (X (m, a) * X (n, a)) ((nat.choose (m + n) m) • X (m + n, a))
| add {n : ℕ} {a b : M} : rel (X (n, a + b)) 
    (finset.sum (range (n + 1)) (λ k, (X (k, a) * X (n - k, b))))

/-- The ideal of mv_polynomial (ℕ × M) R generated by rel -/
def relI : ideal (mv_polynomial (ℕ × M) R) := of_rel (rel R M)

end divided_power_algebra

/-- The divided power algebra of a module M is the quotient of the polynomial ring
by the ring relation defined by divided_power_algebra.rel -/
@[protected, derive [inhabited, comm_ring, algebra R]]
def divided_power_algebra : Type* :=
 (mv_polynomial (ℕ × M) R) ⧸ (divided_power_algebra.relI R M)

namespace divided_power_algebra

/- Note that also we don't know yet that `divided_power_algebra R M` has divided powers, 
  it has a kind of universal property for morphisms to a ring with divided_powers -/

open mv_polynomial

/-- If `R` is a `k`-algebra, then `divided_power_algebra R M` inherits a `k`-algebra structure. -/
instance algebra' (k : Type*) [comm_ring k] [algebra k R] : 
  algebra k (divided_power_algebra R M) :=
ideal.quotient.algebra k  

instance (k : Type*) [comm_ring k] [algebra k R] : 
  is_scalar_tower k R (divided_power_algebra R M) :=
quotient.is_scalar_tower k R (relI R M)

variables {R M}

lemma sub_mem_rel_of_rel {a b : mv_polynomial (ℕ × M) R} (h : rel R M a b) :  a - b ∈ relI R M :=
submodule.subset_span ⟨a, b, h, by rw [sub_add_cancel]⟩

variable (R)
/-- `dp R n m` is the equivalence class of `X (⟨n, m⟩)` in `divided_power_algebra R M`. -/
def dp (n : ℕ) (m : M) : divided_power_algebra R M :=
mkₐ R (relI R M) (X (⟨n, m⟩))

--lemma dp_def (n : ℕ) (m : M) : dp R n m = mkₐ R (relI R M) (X (⟨n, m⟩)) := rfl  --rename?

lemma dp_eq_mkₐ (n : ℕ) (m : M) : dp R n m = mkₐ R (relI R M) (X ⟨n, m⟩) := rfl

lemma dp_eq_mk (n : ℕ) (m : M) : dp R n m = mk (relI R M) (X (⟨n, m⟩ : ℕ × M)) :=
by rw [dp, mkₐ_eq_mk]


lemma dp_zero (m : M) : dp R 0 m = 1 :=
begin
  rw [dp, mkₐ_eq_mk, ← map_one (ideal.quotient.mk (relI R M)), ideal.quotient.eq],
  exact submodule.subset_span ⟨X(0,m), 1, rel.zero, by rw sub_add_cancel⟩
end

lemma dp_smul (r : R) (n  : ℕ) (m : M) : dp R n (r • m) = r ^ n • dp R n m :=
begin
  rw [dp, dp, ← map_smul, mkₐ_eq_mk R, ideal.quotient.eq], 
  exact sub_mem_rel_of_rel rel.smul,
end

lemma dp_null (n : ℕ) : dp R n (0 : M) = ite (n = 0) 1 0 := 
begin
  cases nat.eq_zero_or_pos n with hn hn,
  { rw if_pos hn, rw hn, rw dp_zero, },
  { rw if_neg (ne_of_gt hn), rw ← zero_smul R (0 : M),
    rw dp_smul, rw zero_pow hn, rw zero_smul, },
end

lemma dp_mul (n p : ℕ) (m : M) : dp R n m * dp R p m = (n + p).choose n • dp R (n + p) m :=
begin
  simp only [dp, mkₐ_eq_mk, ← _root_.map_mul, ← map_nsmul, ideal.quotient.eq], 
  exact sub_mem_rel_of_rel rel.mul,
end

lemma dp_add (n : ℕ) (x y : M) : dp R n (x + y) = 
  (range (n+1)).sum (λ k, dp R k x * dp R (n - k) y) := 
begin
  simp only [dp, mkₐ_eq_mk, ← _root_.map_mul, ← map_sum, ideal.quotient.eq], 
  exact sub_mem_rel_of_rel rel.add,
end

lemma dp_sum {ι : Type*} [decidable_eq ι] (x : ι → M) 
  (s : finset ι) (q : ℕ):
  dp R q (s.sum x) = (finset.sym s q).sum (λ k, s.prod (λ i, dp R (multiset.count i k) (x i))) := 
begin
  apply divided_powers.dpow_sum_aux', 
  { intro x, rw dp_zero, }, 
  { intros n x y, rw dp_add, },
  { intros n hn, rw [dp_null R n, if_neg hn], },
end

lemma dp_sum_smul {ι : Type*} [decidable_eq ι] (a : ι → R) (n : ι → ℕ) (x : ι → M) 
  (s : finset ι) (q : ℕ):
  dp R q (s.sum (λ i, a i • x i)) = 
    (finset.sym s q).sum (λ k, s.prod (λ i, (a i) ^ (multiset.count i k)) • 
      s.prod (λ i, dp R (multiset.count i k) (x i))) := 
by simp_rw [dp_sum, dp_smul, algebra.smul_def, map_prod,← finset.prod_mul_distrib]


lemma unique_on_dp {A : Type*} [comm_ring A] [algebra R A]
  {f g : divided_power_algebra R M →ₐ[R] A} (h : ∀ n m, f (dp R n m) = g (dp R n m)) :
  f = g := 
begin
  rw fun_like.ext'_iff,
  apply function.surjective.injective_comp_right (quotient.mkₐ_surjective R (relI R M)),
  simp only [←  alg_hom.coe_comp, ← fun_like.ext'_iff], 
  exact alg_hom_ext (λ ⟨n, m⟩, h n m)
end

section functoriality

variables (R M)

section lift

variables {A : Type*} [comm_ring A] [algebra R A]

/- General purpose lifting lemma -/
lemma lift_rel_le_ker (f : ℕ × M → A) (hf_zero : ∀ m, f (0, m) = 1)
  (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f(⟨n, m⟩)) 
  (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = ((n + p).choose n) • f ⟨n + p, m⟩)
  (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (range (n + 1)).sum (λ (x : ℕ), f ⟨x, u⟩ * f ⟨n - x, v⟩)) :
  relI R M ≤ ring_hom.ker (@eval₂_alg_hom R A (ℕ × M) _ _ _ f) := 
begin
  rw [relI, of_rel, submodule.span_le],
  rintros x ⟨a, b, hx, hab⟩,
  rw [eq_sub_iff_add_eq.mpr hab, set_like.mem_coe, ring_hom.mem_ker, map_sub, sub_eq_zero],
  induction hx with m r n m n p m n u v,
  { rw [eval₂_alg_hom_X', map_one, hf_zero] },
  { simp only [eval₂_alg_hom_X', alg_hom.map_smul, hf_smul] },
  { simp only [_root_.map_mul, eval₂_alg_hom_X', nsmul_eq_mul, map_nat_cast, hf_mul] },
  { simp only [coe_eval₂_alg_hom, eval₂_X, eval₂_sum, eval₂_mul, hf_add] },
end

/-- General purpose universal property of `divided_power_algebra R M` -/
def lift_aux (f : ℕ × M → A) (hf_zero : ∀ m, f (0, m) = 1) 
  (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f(⟨n, m⟩)) 
  (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = ((n + p).choose n) • f ⟨n + p, m⟩)
  (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (range (n + 1)).sum (λ (x : ℕ), f ⟨x, u⟩ * f ⟨n - x, v⟩)) : 
  divided_power_algebra R M →ₐ[R] A :=
liftₐ (relI R M) (eval₂_alg_hom R f) (lift_rel_le_ker R M f hf_zero hf_smul hf_mul hf_add)

lemma lift_aux_eq (f : ℕ × M → A) (hf_zero : ∀ m, f (0, m) = 1) 
  (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f(⟨n, m⟩)) 
  (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = ((n + p).choose n) • f ⟨n + p, m⟩)
  (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (range (n + 1)).sum (λ (x : ℕ), f ⟨x, u⟩ * f ⟨n - x, v⟩)) 
  (p : mv_polynomial (ℕ × M) R) :
  lift_aux R M f hf_zero hf_smul hf_mul hf_add (mkₐ R (relI R M) p) = eval₂ (algebra_map R A) f p :=
by simp only [lift_aux, mkₐ_eq_mk, liftₐ_apply, lift_mk, alg_hom.coe_to_ring_hom, coe_eval₂_alg_hom]

lemma lift_aux_eq_X (f : ℕ × M → A) (hf_zero : ∀ m, f (0, m) = 1) 
  (hf_smul : ∀ (n : ℕ) (r : R) (m : M), f ⟨n, r • m⟩ = r ^ n • f(⟨n, m⟩)) 
  (hf_mul : ∀ n p m, f ⟨n, m⟩ * f ⟨p, m⟩ = ((n + p).choose n) • f ⟨n + p, m⟩)
  (hf_add : ∀ n u v, f ⟨n, u + v⟩ = (range (n + 1)).sum (λ (x : ℕ), f ⟨x, u⟩ * f ⟨n - x, v⟩))  
  (n : ℕ) (m : M) :
  lift_aux R M f hf_zero hf_smul hf_mul hf_add (mkₐ R (relI R M) (X (n, m))) = f ⟨n, m⟩ :=
by rw [lift_aux_eq, eval₂_X]

variables {I : ideal A} (hI : divided_powers I) (φ : M →ₗ[R] A) (hφ : ∀ m, φ m ∈ I)

/-- The “universal” property of divided_power_algebra -/
def lift  : divided_power_algebra R M →ₐ[R] A :=
lift_aux R M (λ nm, hI.dpow nm.1 (φ nm.2)) (λ m, hI.dpow_zero (hφ m)) 
  (λ n r m, by rw [linear_map.map_smulₛₗ, ring_hom.id_apply, ← algebra_map_smul A r (φ m),
    smul_eq_mul, hI.dpow_smul n (hφ m), ← smul_eq_mul, ← map_pow, algebra_map_smul]) 
  (λ n p m, by rw [hI.dpow_mul n p (hφ m), ← nsmul_eq_mul]) 
  (λ n u v, by rw [map_add, hI.dpow_add n (hφ u) (hφ v)]) 

variables {φ}

lemma lift_eqₐ (p : mv_polynomial (ℕ × M) R) : lift R M hI φ hφ (mkₐ R (relI R M) p) = 
  eval₂ (algebra_map R A) (λ (nm : ℕ × M), hI.dpow nm.1 (φ nm.2)) p :=
by rw [lift, lift_aux_eq]

lemma lift_eq (p : mv_polynomial (ℕ × M) R) : lift R M hI φ hφ (mk (relI R M) p) = 
  eval₂ (algebra_map R A) (λ (nm : ℕ × M), hI.dpow nm.1 (φ nm.2)) p :=
by rw [← mkₐ_eq_mk R, lift_eqₐ]

lemma lift_eqₐ_X (n : ℕ) (m : M) :
  lift R M hI φ hφ (mkₐ R (relI R M) (X (n, m))) = hI.dpow n (φ m) :=
by rw [lift, lift_aux_eq_X]

lemma lift_eq_X (n : ℕ) (m : M) :
  lift R M hI φ hφ (mk (relI R M) (X (n, m))) = hI.dpow n (φ m) :=
by rw [← mkₐ_eq_mk R, lift_eqₐ_X]

lemma lift_dp_eq (n : ℕ) (m : M) : 
  lift R M hI φ hφ (dp R n m) = hI.dpow n (φ m) :=
by rw [dp_eq_mk, lift_eq_X]

end lift

section lift'

variables {M}

variables (S : Type*) [comm_ring S] [algebra R S] {N : Type*} [add_comm_group N] [module R N]
  [module S N] [is_scalar_tower R S N] [algebra R (divided_power_algebra S N)]
  [is_scalar_tower R S (divided_power_algebra S N)] (f : M →ₗ[R] N) 

lemma lift'_rel_le_ker :
  relI R M ≤ ring_hom.ker (@eval₂_alg_hom R _ (ℕ × M) _ _ _ (λ nm, dp S nm.1 (f nm.2))) := 
begin
  apply rel_le_ker (relI R M) rfl,
  intros a b hab,
  induction hab with m r n m n p m n u v,
  { simp only [coe_eval₂_hom, eval₂_X, eval₂_one],
    rw dp_zero,  },
  { conv_rhs {rw [← eval₂_alg_hom_apply, map_smul],},
    simp only [eval₂_alg_hom_apply, eval₂_hom_X', linear_map.map_smul],
    rw [← algebra_map_smul S r, ← algebra_map_smul S (r ^ n), dp_smul, map_pow],
    apply_instance, apply_instance, },
  { simp only [coe_eval₂_hom, eval₂_mul, eval₂_X, nsmul_eq_mul], 
    simp only [eval₂_eq_eval_map, map_nat_cast, ← nsmul_eq_mul],
    rw dp_mul, },
  { simp only [map_add, coe_eval₂_hom, eval₂_sum, eval₂_mul, eval₂_X],
    rw dp_add, },
end

/-- The functoriality map between divided power algebras associated with a linear map of the
  underlying modules. Given an `R`-algebra `S`, an `S`-module `N` and `f : M →ₗ[R] N`, this is the
  map `divided_power_algebra R M →ₐ[R] divided_power_algebra S N` that maps `X(n,m)` to `X(n, f m)`.
-/
def lift' : divided_power_algebra R M →ₐ[R] divided_power_algebra S N := 
liftₐ (relI R M) _ (lift'_rel_le_ker R S f)

lemma lift'_eq (p : mv_polynomial (ℕ × M) R) : lift' R S f (mk (relI R M) p) = 
  eval₂ (algebra_map R (divided_power_algebra S N)) (λ nm : ℕ × M, dp S nm.1 (f nm.2)) p := 
by simp only [lift', liftₐ_apply, lift_mk, alg_hom.coe_to_ring_hom, coe_eval₂_alg_hom]

lemma lift'_eqₐ (p : mv_polynomial (ℕ × M) R) : lift' R S f (mkₐ R (relI R M) p) = 
  eval₂ (algebra_map R (divided_power_algebra S N)) (λ nm : ℕ × M, dp S nm.1 (f nm.2)) p := 
by rw [mkₐ_eq_mk, lift'_eq]

lemma lift'_dp_eq (n : ℕ) (m : M) : 
  lift' R S f (dp R n m) = dp S n (f m) := 
by rw [dp_eq_mk, lift'_eq, eval₂_X]

end lift'

end functoriality

end divided_power_algebra

end 

--#lint