import divided_powers.dp_algebra

open divided_powers

/- variables (A : Type*) [comm_ring A] {I : ideal A} (hI : divided_powers I) (B : Type*) [comm_ring B]
  [algebra A B] (J : ideal B) -/

def is_universal (A : Type*) [comm_ring A] {I : ideal A} (hI : divided_powers I) (B : Type*) 
  [comm_ring B] [algebra A B] (J : ideal B)(D : Type*) [comm_ring D] {J' : ideal D} 
  (hJ' : divided_powers J') (ψ : B →+* D) (hψ : ψ '' J ⊆ J') :=
∀ (C : Type*) [comm_ring C], by exactI ∀ (K : ideal C) (hK : divided_powers K)
  (g : pd_morphism hI hK) (h : B →+* C) (hh : h '' J ⊆ K) 
  (hcomp : h ∘ (algebra_map A B) = g.to_ring_hom),
  ∃! (φ : pd_morphism hJ' hK), φ.to_ring_hom ∘ ψ = h 

-- Theorem 3.19 Berthelot-Ogus
theorem exists_dp_envelope (A B : Type*) [comm_ring A] {I : ideal A} (hI : divided_powers I)
  [comm_ring B] [algebra A B] (J : ideal B) :
  ∃ (D : Type*) [hD : comm_ring D], by exactI ∃ {J' : ideal D} (hJ' : divided_powers J')
  (ψ : B →+* D) (hψ : ψ '' J ⊆ J'), is_universal A hI B J D hJ' ψ hψ :=
sorry

namespace divided_power_envelope

variables (A B : Type*) [comm_ring A] {I : ideal A} (hI : divided_powers I) [comm_ring B] 
  [algebra A B] (J : ideal B) 

section included

variables (hIJ : (algebra_map A B)'' I ⊆ J)
/- 
/-  The class of X (n, a) will be equal to dpow n a, with a ∈ M. --/
inductive rel : (mv_polynomial (ℕ × M) R) → (mv_polynomial (ℕ × M) R) → Prop 
  --rel (mv_polynomial (ℕ × M) R) (mv_polynomial (ℕ × M) R) Q : Why not use rel?
-- force `ι` to be linear and creates the divided powers
| zero {a : M} : rel (X (0, a)) 1
| smul {r : R} {n : ℕ} {a : M} : rel (X (n, r • a)) (r^n • X (n, a))
| mul {m n : ℕ} {a : M} : rel (X (m, a) * X (n, a)) ((nat.choose (m + n) m) • X (m + n, a))
| add {n : ℕ} {a b : M} : rel (X (n, a + b)) 
    (finset.sum (range (n + 1)) (λ k, (X (k, a) * X (n - k, b))))

/-- The ideal of mv_polynomial (ℕ × M) R generated by rel -/
def relI : ideal (mv_polynomial (ℕ × M) R) := of_rel (rel R M)-/ 

open ideal divided_power_algebra

inductive rel1 : _root_.rel (divided_power_algebra B J) (divided_power_algebra B J)
| rel {x : J} : rel1 (ι B x) (algebra_map _ _ (x : B))

noncomputable def J1 : ideal (divided_power_algebra B J) := of_rel (rel1 B J)

include hIJ

inductive rel2 : _root_.rel (divided_power_algebra B J) (divided_power_algebra B J)
| rel {x : I} {n : ℕ} : rel2
  (dp B n (⟨(algebra_map A B x), hIJ ( set.mem_image_of_mem _ x.2)⟩ : J))
  (algebra_map _ _ (algebra_map A B (dpow hI n x ))) --(algebra_map _ _ (x : B))

noncomputable def J2 : ideal (divided_power_algebra B J) := of_rel (rel2 A B hI J hIJ)

noncomputable def J12 : ideal (divided_power_algebra B J) := J1 B J + J2 A B hI J hIJ

--theorem asd : is_sub_pd_ideal J12 ⊓ (aug_ideal B J) 

end included

end divided_power_envelope